<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        剪枝裁叶
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            Go语言从入门到实战笔记
        </p>
        <hr>
    </div>
    <div class="post-content">
        <blockquote>
<p>源码地址： <a target="_blank" rel="noopener" href="https://gitee.com/geektime-geekbang/go_learning">https://gitee.com/geektime-geekbang/go_learning</a><br>or <a target="_blank" rel="noopener" href="https://github.com/geektime-geekbang/go_learning/">https://github.com/geektime-geekbang/go_learning/</a></p>
</blockquote>
<h1 id="go-yu-yan-cong-ru-men-dao-shi-zhan-bi-ji"><span id="go-yu-yan-cong-ru-men-dao-shi-zhan-bi-ji">Go 语言从入门到实战 笔记</span><a href="#go-yu-yan-cong-ru-men-dao-shi-zhan-bi-ji" class="header-anchor">#</a></h1><h1 id="ji-chu-bu-fen"><span id="ji-chu-bu-fen">基础部分</span><a href="#ji-chu-bu-fen" class="header-anchor">#</a></h1><h2 id="chai-yi-yu-ji-chu"><span id="chai-yi-yu-ji-chu">差异与基础</span><a href="#chai-yi-yu-ji-chu" class="header-anchor">#</a></h2><h3 id="tui-chu-fan-hui-zhi"><span id="tui-chu-fan-hui-zhi">退出返回值</span><a href="#tui-chu-fan-hui-zhi" class="header-anchor">#</a></h3><ul>
<li>Go中<code>main</code>函数不支持任何返回值</li>
<li>通过<code>os.Exit</code>来返回状态</li>
</ul>
<h3 id="huo-qu-ming-ling-xing-can-shu"><span id="huo-qu-ming-ling-xing-can-shu">获取命令行参数</span><a href="#huo-qu-ming-ling-xing-can-shu" class="header-anchor">#</a></h3><ul>
<li><code>main</code>函数不支持传入参数</li>
<li>在程序中直接用过<code>os.Args</code>获取命令行参数</li>
</ul>
<h3 id="bian-liang-fu-zhi"><span id="bian-liang-fu-zhi">变量赋值</span><a href="#bian-liang-fu-zhi" class="header-anchor">#</a></h3><ul>
<li>赋值可以进行自动类型推断</li>
<li>在一个赋值语句中可以对多个变量进行同时赋值</li>
</ul>
<h3 id="kuai-su-she-zhi-lian-xu-zhi"><span id="kuai-su-she-zhi-lian-xu-zhi">快速设置连续值</span><a href="#kuai-su-she-zhi-lian-xu-zhi" class="header-anchor">#</a></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    Monday = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">    Sunday</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Open = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span></span><br><span class="line">    Close</span><br><span class="line">    Pending</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="lei-xing-zhuan-hua"><span id="lei-xing-zhuan-hua">类型转化</span><a href="#lei-xing-zhuan-hua" class="header-anchor">#</a></h3><ol>
<li>Go语言不允许隐式类型转换</li>
<li>别名和原有类型也不能进行隐式类型转换</li>
</ol>
<h3 id="zhi-zhen-lei-xing"><span id="zhi-zhen-lei-xing">指针类型</span><a href="#zhi-zhen-lei-xing" class="header-anchor">#</a></h3><ol>
<li>不支持指针运算</li>
<li><code>string</code>是值类型，其默认得初始化值为空字符串，而不是<code>nil</code></li>
</ol>
<h3 id="suan-zhu-yun-suan-fu"><span id="suan-zhu-yun-suan-fu">算术运算符</span><a href="#suan-zhu-yun-suan-fu" class="header-anchor">#</a></h3><blockquote>
<p>Go语言没用前置得++,–, <del>(++a)</del></p>
</blockquote>
<h3 id="yong-bi-jiao-shu-zu"><span id="yong-bi-jiao-shu-zu">用<code>==</code>比较数组</span><a href="#yong-bi-jiao-shu-zu" class="header-anchor">#</a></h3><ul>
<li>相同维数且含有相同个数元素得的数组才可以比较</li>
<li>每个元素都相同的才相等</li>
</ul>
<h3 id="wei-yun-suan-fu-amp-an-wei-zhi-ling"><span id="wei-yun-suan-fu-amp-an-wei-zhi-ling">位运算符，<code>&amp;^按位置零</code></span><a href="#wei-yun-suan-fu-amp-an-wei-zhi-ling" class="header-anchor">#</a></h3><p><code>1 &amp;^ 0 -- 1</code><br><code>1 &amp;^ 1 -- 0</code><br><code>0 &amp;^ 1 -- 0</code><br><code>0 &amp;^ 0 -- 0</code></p>
<h3 id="xun-huan"><span id="xun-huan">循环</span><a href="#xun-huan" class="header-anchor">#</a></h3><p>while 条件循环<br>while (n&lt;5)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n := 0</span><br><span class="line">for n &lt; 5&#123;</span><br><span class="line">    n++</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无限循环<br>while(true)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n := 0</span><br><span class="line">for &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="if-tiao-jian"><span id="if-tiao-jian">if条件</span><a href="#if-tiao-jian" class="header-anchor">#</a></h3><ol>
<li><code>condition</code>表达式结果必须为布尔值</li>
<li>支持变量赋值:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">var</span> declaration; condition &#123;</span><br><span class="line">    <span class="comment">// code to be executed if confition is true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="switch-tiao-jian"><span id="switch-tiao-jian">switch条件</span><a href="#switch-tiao-jian" class="header-anchor">#</a></h3><ol>
<li>条件表达式不限制为常量或者整数;</li>
<li>单个case中，可以出现多个结果选项，是用逗号分隔;</li>
<li>与C语言等规则相反，Go语言不需要用break来明确退出一个case;</li>
<li>可以不设定switch之后的条件表达式，在此种情况下,整个switch结构与多个<code>if...else...</code>的逻辑作用等同</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch os := runtime.GOOS;os&#123;</span><br><span class="line">    case &quot;darwin&quot;:</span><br><span class="line">        fmt.Println(&quot;OS X.&quot;)</span><br><span class="line">    case &quot;linux&quot;:</span><br><span class="line">        fmt.Println(&quot;Linux.&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;%s.&quot;, os)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch&#123;</span><br><span class="line">    case 0 &lt;= Num &amp;&amp; Num &lt;= 3:</span><br><span class="line">        fmt.Printf(&quot;0-3&quot;)</span><br><span class="line">    case 4 &lt;= Num &amp;&amp; Num &lt;= 6:</span><br><span class="line">        fmt.Printf(&quot;4-6&quot;)</span><br><span class="line">    case 7 &lt;= Num &amp;&amp; Num &lt;= 9:</span><br><span class="line">        fmt.Printf(&quot;7-9&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="qie-pian"><span id="qie-pian">切片</span><a href="#qie-pian" class="header-anchor">#</a></h3><h4 id="qie-pian-sheng-ming"><span id="qie-pian-sheng-ming">切片声明：</span><a href="#qie-pian-sheng-ming" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var s0[] int // 数组中[]需要填值或者...填充数</span><br><span class="line">s0 = append(s0, 1)</span><br><span class="line"></span><br><span class="line">s := []int&#123;&#125;</span><br><span class="line"></span><br><span class="line">s1 := []int&#123;1,2,3&#125;</span><br><span class="line"></span><br><span class="line">s2 := nake([]int, 2, 4)</span><br><span class="line">/*</span><br><span class="line">    type, len, cap</span><br><span class="line">    其中len个元素会被初始化为默认零值，未初始化元素不可以访问</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/08/26/8csOonqHEUYC9MK.png" alt="image.png"></p>
<h4 id="qie-pian-ru-he-shi-xian-ke-bian-chang"><span id="qie-pian-ru-he-shi-xian-ke-bian-chang">切片如何实现可变长</span><a href="#qie-pian-ru-he-shi-xian-ke-bian-chang" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=append(s,i) // 地址发生变化</span><br></pre></td></tr></table></figure>

<h3 id="map-sheng-ming"><span id="map-sheng-ming">Map声明</span><a href="#map-sheng-ming" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m := map[string]int&#123;&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3&#125;</span><br><span class="line"></span><br><span class="line">m1 = map[string]int&#123;&#125;</span><br><span class="line"></span><br><span class="line">m1[&quot;one&quot;] = 1</span><br><span class="line"></span><br><span class="line">m2 := make(map[string]int, 10/* 初始化cap*/)</span><br></pre></td></tr></table></figure>

<h4 id="map-yuan-su-de-fang-wen"><span id="map-yuan-su-de-fang-wen">Map元素的访问</span><a href="#map-yuan-su-de-fang-wen" class="header-anchor">#</a></h4><p>在访问的<code>key</code>不存在时，仍会返回零值，不能通过返回<code>nil</code>来判断元素是否存在</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m1 := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> v, ok := m1[<span class="number">3</span>]; ok &#123;</span><br><span class="line">		t.Logf(<span class="string">&quot;key 3`s value is %d&quot;</span>, v)</span><br><span class="line">		t.Log(v, ok)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		t.Log(<span class="string">&quot;key 3 is not existing.&quot;</span>)</span><br><span class="line">		t.Log(v, ok)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="map-bian-li"><span id="map-bian-li">Map遍历</span><a href="#map-bian-li" class="header-anchor">#</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m1 := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="number">3</span>: <span class="number">9</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">		t.Log(k, v)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="map-yu-gong-han-mo-shi"><span id="map-yu-gong-han-mo-shi">Map与工厂模式</span><a href="#map-yu-gong-han-mo-shi" class="header-anchor">#</a></h4><ul>
<li><code>Map</code>的<code>value</code>可以是一个方法</li>
<li>与Go的<code>Dock type</code>接口方式一起，可以方便的实现单一方法对象的工厂模式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m := map[int]func(op int) int&#123;&#125;</span><br><span class="line">m[1] = func(op int) int &#123; return op &#125;</span><br><span class="line">m[2] = func(op int) int &#123; return op * op &#125;</span><br><span class="line">m[3] = func(op int) int &#123; return op * op * op &#125;</span><br><span class="line">t.Log(m[1](2), m[2](2), m[3](2))</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="shi-xian-set"><span id="shi-xian-set">实现Set</span><a href="#shi-xian-set" class="header-anchor">#</a></h3><p>Go的内置集合中没有<code>Set</code>实现，可以map[type]bool</p>
<ol>
<li>&#x3D;&#x3D;元素的唯一性&#x3D;&#x3D;</li>
<li>基本操作<ol>
<li>添加元素</li>
<li>判断元素是否存在</li>
<li>删除元素</li>
<li>元素个数</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mySet := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">mySet[<span class="number">1</span>] = <span class="literal">true</span></span><br><span class="line">n := <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> mySet[n] &#123;</span><br><span class="line">	t.Logf(<span class="string">&quot;%d is existing&quot;</span>, n)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	t.Logf(<span class="string">&quot;%d is not existing&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line">mySet[<span class="number">3</span>] = <span class="literal">true</span></span><br><span class="line">t.Log(<span class="built_in">len</span>(mySet))</span><br><span class="line"><span class="built_in">delete</span>(mySet, <span class="number">1</span>)</span><br><span class="line"><span class="comment">//t.Log(len(mySet))</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> mySet[n] &#123;</span><br><span class="line">	t.Logf(<span class="string">&quot;%d is existing&quot;</span>, n)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	t.Logf(<span class="string">&quot;%d is not existing&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="zi-fu-chuan"><span id="zi-fu-chuan">字符串</span><a href="#zi-fu-chuan" class="header-anchor">#</a></h3><ol>
<li>string是数据类型，不是引用或指针类型</li>
<li>string是只读的<code>byte slice</code>, len函数可以查它所包含的<code>byte</code>数</li>
<li>string的<code>byte</code>数组可以存放任何数据</li>
</ol>
<h4 id="unicode-utf8"><span id="unicode-utf8">Unicode UTF8</span><a href="#unicode-utf8" class="header-anchor">#</a></h4><ol>
<li>Unicode 是一种字符集（code point）</li>
<li>UTF8 是 <code>unicode</code> 的存储实现（转换为字节系列的规则）<br><img src="https://s2.loli.net/2022/08/26/wkI6gjR3tzd4xTb.png" alt="image.png"></li>
</ol>
<h4 id="string-zhuan-rune"><span id="string-zhuan-rune">String转<code>rune</code></span><a href="#string-zhuan-rune" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := &quot;去隔壁吃辣条&quot;</span><br><span class="line">for _, c := range s &#123;</span><br><span class="line">	t.Logf(&quot;%[1]c %[1]x %[1]d %[2]x&quot;, c, string(c)) // &quot;[]&quot;中的数字代表抵</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="chang-yong-de-zi-fu-chuan-han-shu"><span id="chang-yong-de-zi-fu-chuan-han-shu">常用的字符串函数</span><a href="#chang-yong-de-zi-fu-chuan-han-shu" class="header-anchor">#</a></h3><ol>
<li>strings包</li>
<li>strconv包<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := &quot;A,B,C&quot;</span><br><span class="line">parts := strings.Split(s, &quot;,&quot;)</span><br><span class="line">for _, part := range parts &#123;</span><br><span class="line">	t.Log(part)</span><br><span class="line">&#125;</span><br><span class="line">t.Log(strings.Join(parts, &quot;-&quot;))</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := strconv.Itoa(10)</span><br><span class="line">t.Log(&quot;str&quot; + s)</span><br><span class="line">if i, err := strconv.Atoi(&quot;10&quot;); err == nil &#123;</span><br><span class="line">	t.Log(10 + i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="han-shu-shi-yi-deng-gong-min"><span id="han-shu-shi-yi-deng-gong-min">函数是一等公民</span><a href="#han-shu-shi-yi-deng-gong-min" class="header-anchor">#</a></h3><ol>
<li>可以有多个返回值</li>
<li>所有参数都是值传递：slice, map, channel会有传引用的错觉</li>
<li>函数可以作为变量的值</li>
<li>函数可以作为参数和返回值</li>
</ol>
<h4 id="ke-bian-can-shu"><span id="ke-bian-can-shu">可变参数</span><a href="#ke-bian-can-shu" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func Sum(ops ...int) int &#123;</span><br><span class="line">	ret := 0</span><br><span class="line">	for _, op := range ops &#123;</span><br><span class="line">		ret += op</span><br><span class="line">	&#125;</span><br><span class="line">	return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestVarParam(t *testing.T) &#123;</span><br><span class="line">	t.Log(Sum(1, 2, 3, 4))</span><br><span class="line">	t.Log(Sum(1, 2, 3, 4, 5))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="defer-han-shu"><span id="defer-han-shu"><code>defer</code>函数</span><a href="#defer-han-shu" class="header-anchor">#</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Clear resources.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDefer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> Clear()</span><br><span class="line">	fmt.Println(<span class="string">&quot;Start&quot;</span>)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;err&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="go-de-cuo-wu-ji-zhi"><span id="go-de-cuo-wu-ji-zhi">Go的错误机制</span><a href="#go-de-cuo-wu-ji-zhi" class="header-anchor">#</a></h3><ol>
<li>没有异常机制</li>
<li>error 类型实现了 <code>error</code>接口<blockquote>
<p>及早失败，避免嵌套！</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">    Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可以通过<code>errors.New</code>来快速创建实例<br><code>errors.New(&quot;n must be in the range [0,10]&quot;)</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var LessThanTwoError = errors.New(&quot;n should be not less than 2&quot;)</span><br><span class="line">var LargerThenHundredError = errors.New(&quot;n should be not larger than 100&quot;)</span><br><span class="line"></span><br><span class="line">func GetFibonacci(n int) ([]int, error) &#123;</span><br><span class="line">	if n &lt; 2 &#123;</span><br><span class="line">		return nil, LessThanTwoError</span><br><span class="line">	&#125;</span><br><span class="line">	if n &gt; 100 &#123;</span><br><span class="line">		return nil, LargerThenHundredError</span><br><span class="line">	&#125;</span><br><span class="line">	fibList := []int&#123;1, 1&#125;</span><br><span class="line">	for i := 2; i &lt; n; i++ &#123;</span><br><span class="line">		fibList = append(fibList, fibList[i-2]+fibList[i-1])</span><br><span class="line">	&#125;</span><br><span class="line">	return fibList, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestGetFibonacci(t *testing.T) &#123;</span><br><span class="line">	if v, err := GetFibonacci(-10); err != nil &#123;</span><br><span class="line">		if err == LessThanTwoError &#123;</span><br><span class="line">			fmt.Println(&quot;It is less.&quot;)</span><br><span class="line">		&#125;</span><br><span class="line">		t.Error(err)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		t.Log(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="panic"><span id="panic">panic</span><a href="#panic" class="header-anchor">#</a></h4><ul>
<li><code>panic</code>用于不可以恢复的错误</li>
<li><code>panic</code>退出前会执行<code>defer</code>指定的内容</li>
</ul>
<h4 id="panic-vs-os-exit"><span id="panic-vs-os-exit"><code>panic</code> VS <code>os.Exit</code></span><a href="#panic-vs-os-exit" class="header-anchor">#</a></h4><ul>
<li><code>os.Exit</code>退出时不会调用<code>defer</code>指定的函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func TestPanicVxExit(t *testing.T) &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		fmt.Println(&quot;Finally&quot;)</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(&quot;Start&quot;)</span><br><span class="line">	os.Exit(-1)</span><br><span class="line">	//panic(errors.New(&quot;something wrong&quot;))</span><br><span class="line">	//fmt.Println(&quot;End&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>&#x3D;&#x3D;console:&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestPanicVxExit</span><br><span class="line">Start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>没打印<code>Finally</code></p>
</blockquote>
<ul>
<li><code>os.Exit</code>退出时不输出当前调用栈信息</li>
</ul>
<h4 id="bu-huo-suo-you-cuo-wu-recover"><span id="bu-huo-suo-you-cuo-wu-recover">捕获所有错误 recover</span><a href="#bu-huo-suo-you-cuo-wu-recover" class="header-anchor">#</a></h4><p><img src="https://s2.loli.net/2022/08/26/XML9bymS7EqnirW.png" alt="image.png"></p>
<blockquote>
<p>在<code>GO</code>语言中recover</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defer func() &#123;</span><br><span class="line">    if err := recover(); err != nil &#123;</span><br><span class="line">        // 恢复错误</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>recover()</code>返回的是<code>panic</code>的<code>error</code>例如：<code>panic(error.New(&quot;错误信息&quot;))</code></p>
</blockquote>
<h4 id="x3d-x3d-shi-yong-recover-xu-jin-shen-x3d-x3d"><span id="x3d-x3d-shi-yong-recover-xu-jin-shen-x3d-x3d">&#x3D;&#x3D;使用<code>recover</code>需谨慎&#x3D;&#x3D;</span><a href="#x3d-x3d-shi-yong-recover-xu-jin-shen-x3d-x3d" class="header-anchor">#</a></h4><ul>
<li>形成僵尸服务进程，导致<code>health check</code>失效</li>
<li>“Let it Crash!”往往是我们恢复不确定性错误的最好方法。<blockquote>
<p>该退出重启时则退出重启（重启是恢复不确定性的最好办法，哈哈~ 建议：重启多次，则让程序自行退出），程序运行中别急着通过<code>recover</code>修复</p>
</blockquote>
</li>
</ul>
<h2 id="go-de-yi-lai-guan-li"><span id="go-de-yi-lai-guan-li">GO的依赖管理</span><a href="#go-de-yi-lai-guan-li" class="header-anchor">#</a></h2><h3 id="package"><span id="package">package</span><a href="#package" class="header-anchor">#</a></h3><ol>
<li><strong>基本复用模块单元</strong><blockquote>
<p>以首字母大写来表明可被包外代码访问</p>
</blockquote>
</li>
<li>代码的<code>package</code>可以和所在的目录不一致</li>
<li>同一目录里的Go代码的<code>package</code>要保持一致</li>
</ol>
<h4 id="remote-package"><span id="remote-package">remote package</span><a href="#remote-package" class="header-anchor">#</a></h4><ol>
<li>通过<code>get get</code>来获取远程依赖</li>
</ol>
<ul>
<li><code>go get -u</code> 强制从网络更新远程依赖</li>
</ul>
<ol start="2">
<li>注意代码在Github上的组织形式，以适应<code>go get</code></li>
</ol>
<ul>
<li>直接以代码路径开始，不要有<code>src</code><blockquote>
<p>国内需要设置以一下Go代理</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>
<p><strong>例子</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/easierway/concurrent_map</span><br></pre></td></tr></table></figure>
<p><strong>使用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package remote_package</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	cm &quot;github.com/easierway/concurrent_map&quot;</span><br><span class="line">	&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func TestConcurrentMap(t *testing.T) &#123;</span><br><span class="line">	m := cm.CreateConcurrentMap(99)</span><br><span class="line">	m.Set(cm.StrKey(&quot;key&quot;), 10)</span><br><span class="line">	t.Log(m.Get(cm.StrKey(&quot;key&quot;)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="init-fang-fa"><span id="init-fang-fa">init方法</span><a href="#init-fang-fa" class="header-anchor">#</a></h3><ul>
<li>在<code>main</code>被执行前，所有依赖的<code>package</code>的<code>init</code>方法都会被执行</li>
<li>不同包的<code>init</code>函数按照包导入的依赖关系决定执行顺序</li>
<li>每个包可以有多个<code>init</code>函数</li>
<li><strong>包的每个源程序也可以有多个<code>init</code>函数</strong>，这点比较特殊</li>
</ul>
<h4 id="init-han-shu-de-zhu-yao-zuo-yong"><span id="init-han-shu-de-zhu-yao-zuo-yong"><code>init</code>函数的主要作用：</span><a href="#init-han-shu-de-zhu-yao-zuo-yong" class="header-anchor">#</a></h4><ul>
<li>初始化不能采用初始化表达式初始化的变量。</li>
<li>程序运行前的注册。</li>
<li>实现<code>sync.Once</code>功能。</li>
</ul>
<h4 id="init-han-shu-de-zhu-yao-te-dian"><span id="init-han-shu-de-zhu-yao-te-dian"><code>init</code>函数的主要特点：</span><a href="#init-han-shu-de-zhu-yao-te-dian" class="header-anchor">#</a></h4><ul>
<li><code>init</code>函数先于<code>main</code>函数自动执行，不能被其他函数调用；</li>
<li>init函数没有输入参数、返回值；<br>每个包可以有多个init函数；</li>
<li><strong>包的每个源文件也可以有多个init函数</strong>，这点比较特殊；<br>-同一个包的init执行顺序，golang没有明确定义，编程时要注意程序不要依赖 这个执行顺序。</li>
<li>不同包的init函数按照包导入的依赖关系决定执行顺序。</li>
</ul>
<blockquote>
<p>初始化顺序：<code>变量初始化-&gt;init()-&gt;main()</code></p>
</blockquote>
<h3 id="go-wei-jie-jue-de-yi-lai-wen-ti"><span id="go-wei-jie-jue-de-yi-lai-wen-ti">Go未解决的依赖问题</span><a href="#go-wei-jie-jue-de-yi-lai-wen-ti" class="header-anchor">#</a></h3><ol>
<li>同一环境下，不同项目使用同一包的不同版本</li>
<li>无法管理对包的特定版本的依赖</li>
</ol>
<h4 id="vendor-lu-jing"><span id="vendor-lu-jing">vendor路径</span><a href="#vendor-lu-jing" class="header-anchor">#</a></h4><p><strong>查找依赖包管理的解决方法如下</strong></p>
<ol>
<li>当前包下的<code>vendor</code>目录</li>
<li>向上级目录查找，直到找到<code>src</code>下的<code>vendor</code>目录</li>
<li>在<code>GOPATH</code>下面查找依赖包</li>
<li>在<code>GOROOT</code>目录下查找</li>
</ol>
<h4 id="chang-yong-de-yi-lai-guan-li-gong-ju"><span id="chang-yong-de-yi-lai-guan-li-gong-ju">常用的依赖管理工具</span><a href="#chang-yong-de-yi-lai-guan-li-gong-ju" class="header-anchor">#</a></h4><ul>
<li>godep <a target="_blank" rel="noopener" href="https://github.com/tools/godep">https://github.com/tools/godep</a></li>
<li>glide <a target="_blank" rel="noopener" href="https://github.com/Masterminds/glide">https://github.com/Masterminds/glide</a></li>
<li>dep <a target="_blank" rel="noopener" href="https://qithub.com/golang/dep">https://qithub.com/golang/dep</a></li>
</ul>
<h2 id="go-de-jiao-cha-bian-yi"><span id="go-de-jiao-cha-bian-yi">Go的交叉编译</span><a href="#go-de-jiao-cha-bian-yi" class="header-anchor">#</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我的电脑  <span class="number">17</span>:<span class="number">32</span>:<span class="number">12</span></span><br><span class="line">CGO_ENABLED=<span class="number">0</span> GOOS=linux GOARCH=amd64 <span class="keyword">go</span> build -p <span class="number">2</span> xxxx.<span class="keyword">go</span></span><br><span class="line">CGO_ENABLED=<span class="number">0</span> GOOS=linux GOARCH=arm64 <span class="keyword">go</span> build -o xxxx-linux-arm64 -p <span class="number">2</span> xxxx.<span class="keyword">go</span></span><br><span class="line">CGO_ENABLED=<span class="number">0</span> GOOS=windows GOARCH=amd64 <span class="keyword">go</span> build -p <span class="number">2</span> xxxx.<span class="keyword">go</span></span><br><span class="line">CGO_ENABLED=<span class="number">0</span> GOOS=darwin GOARCH=amd64 <span class="keyword">go</span> build -o  xxxx-darwin-amd64 -p <span class="number">2</span> xxxx.<span class="keyword">go</span></span><br><span class="line">CGO_ENABLED=<span class="number">0</span> GOOS=darwin GOARCH=arm64 <span class="keyword">go</span> build -o  xxxx-darwin-arm64 -p <span class="number">2</span> xxxx.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<h2 id="bing-fa-bian-cheng"><span id="bing-fa-bian-cheng">并发编程</span><a href="#bing-fa-bian-cheng" class="header-anchor">#</a></h2><h3 id="thread-vs-groutine"><span id="thread-vs-groutine">Thread VS Groutine</span><a href="#thread-vs-groutine" class="header-anchor">#</a></h3><ol>
<li>创建时默认的<code>stack</code>的大小</li>
</ol>
<ul>
<li><code>JDK5</code> 以后 <code>Java Thread stack</code> 默认为1M</li>
<li><code>Groutine</code>的<code>stack</code>初始化大小为2K</li>
</ul>
<ol start="2">
<li>和<code>KSE</code>（Kernel Space Entity）的对应关系</li>
</ol>
<ul>
<li><code>Java Thread</code> 是1:1</li>
<li><code>Groutine</code>是M:N<br><img src="https://s2.loli.net/2022/08/26/LE4ld9PxXWJfM3r.png" alt="image.png"><br><img src="https://s2.loli.net/2022/08/26/mC2ahfeOJVBXoNE.png" alt="image.png"></li>
</ul>
<h3 id="gong-xiang-nei-cun-bing-fa-ji-zhi"><span id="gong-xiang-nei-cun-bing-fa-ji-zhi">共享内存并发机制</span><a href="#gong-xiang-nei-cun-bing-fa-ji-zhi" class="header-anchor">#</a></h3><h4 id="sync-mutex-hu-chi-suo"><span id="sync-mutex-hu-chi-suo"><code>sync.Mutex</code> 互斥锁</span><a href="#sync-mutex-hu-chi-suo" class="header-anchor">#</a></h4><blockquote>
<p>互斥：防止两条线程同时对同一公共资源（比如全域變數）进行读写的机制</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func TestCounterThreadSafe(t *testing.T) &#123;</span><br><span class="line">	var mut sync.Mutex</span><br><span class="line">	counter := 0</span><br><span class="line">	for i := 0; i &lt; 5000; i++ &#123;</span><br><span class="line">		go func() &#123;</span><br><span class="line">			defer func() &#123; // 使用defer 是为了防止一些异常操作导致锁无法正确释放</span><br><span class="line">				mut.Unlock()</span><br><span class="line">			&#125;()</span><br><span class="line">			mut.Lock()</span><br><span class="line">			counter++</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(1 * time.Second)</span><br><span class="line">	t.Logf(&quot;counter = %d&quot;, counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sync-waitgroup-tong-bu-xian-cheng-lei-si-java-zhong-de-join"><span id="sync-waitgroup-tong-bu-xian-cheng-lei-si-java-zhong-de-join"><code>sync.WaitGroup</code>同步线程 类似<code>java</code>中的<code>join</code></span><a href="#sync-waitgroup-tong-bu-xian-cheng-lei-si-java-zhong-de-join" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func TestCounterWaitGroup(t *testing.T) &#123;</span><br><span class="line">	var mut sync.Mutex</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	counter := 0</span><br><span class="line">	for i := 0; i &lt; 5000; i++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			defer func() &#123;</span><br><span class="line">				mut.Unlock()</span><br><span class="line">			&#125;()</span><br><span class="line">			mut.Lock()</span><br><span class="line">			counter++</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	t.Logf(&quot;counter = %d&quot;, counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="csp-bing-fa-ji-zhi-go-yu-yan-te-you-de"><span id="csp-bing-fa-ji-zhi-go-yu-yan-te-you-de">CSP并发机制（Go语言特有的）</span><a href="#csp-bing-fa-ji-zhi-go-yu-yan-te-you-de" class="header-anchor">#</a></h3><blockquote>
<p>CSP (Communicating sequential processes) 通信顺序进程<br>CSP 是一种形式语言，用来描述并发性系统间进行交互的模式。它是叫做进程代数或进程演算的关于并发的数学理论家族的一员，基于了通过通道的消息传递</p>
</blockquote>
<ul>
<li><code>Actor Model</code><br><img src="https://s2.loli.net/2022/08/26/I7JgmpRrWvFEqSc.png" alt="image.psd.png"></li>
</ul>
<h4 id="csp-vs-actor"><span id="csp-vs-actor"><code>CSP</code> vs <code>Actor</code></span><a href="#csp-vs-actor" class="header-anchor">#</a></h4><ul>
<li>和<code>Actor</code>的直接通讯不同，<code>CSP</code>模式则是通过<code>Channel</code>进行通讯的，更松耦合一些。</li>
<li><code>Go</code>中<code>channel</code>是有容量限制并且独立于处理<code>Groutine</code>，而如<code>Erlang</code>，<code>Actor</code>模式中的<code>mailbox</code>容量是无限的，接受进程也总是被动地处理消息<br><img src="https://s2.loli.net/2022/08/26/tM1mERb7kVg8yjr.png" alt="image.png"></li>
</ul>
<h4 id="channel"><span id="channel">Channel</span><a href="#channel" class="header-anchor">#</a></h4><p><img src="https://s2.loli.net/2022/08/26/NFtXnfChJdeTBWp.png" alt="image.psd.png"></p>
<p><img src="https://s2.loli.net/2022/08/26/PO7CfGQ5rYsvHlR.png" alt="image.png"></p>
<h3 id="duo-lu-xuan-ze-he-chao-shi"><span id="duo-lu-xuan-ze-he-chao-shi">多路选择和超时</span><a href="#duo-lu-xuan-ze-he-chao-shi" class="header-anchor">#</a></h3><h4 id="duo-lu-xuan-ze"><span id="duo-lu-xuan-ze">多路选择</span><a href="#duo-lu-xuan-ze" class="header-anchor">#</a></h4><blockquote>
<p>如果多个case同时就绪时，select会随机地选择一个执行，这样来保证每一个channel都有平等的被select的机会</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">    case ret := &lt;-retCh1:</span><br><span class="line">        t.Logf(&quot;result %s&quot;, ret)</span><br><span class="line">    case ret := &lt;-retCh2:</span><br><span class="line">        t.Logf(&quot;result %s&quot;, ret)</span><br><span class="line">    default:</span><br><span class="line">        t.Error(&quot;No one returned&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="chao-shi-kong-zhi"><span id="chao-shi-kong-zhi">超时控制</span><a href="#chao-shi-kong-zhi" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">    case ret := &lt;-retCh:</span><br><span class="line">        t.Logf(&quot;result %s&quot;, ret)</span><br><span class="line">    case &lt;-time.After(time.Second * 1):</span><br><span class="line">        t.Error(&quot;time out&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Example</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func service() string &#123;</span><br><span class="line">	time.Sleep(time.Millisecond * 50)</span><br><span class="line">	return &quot;Done&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func otherTask() &#123;</span><br><span class="line">	fmt.Println(&quot;working on something else&quot;)</span><br><span class="line">	time.Sleep(time.Millisecond * 100)</span><br><span class="line">	fmt.Println(&quot;Task is done.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func AsyncService() chan string &#123;</span><br><span class="line">	//retCh := make(chan string)</span><br><span class="line">	retCh := make(chan string, 1)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		ret := service()</span><br><span class="line">		fmt.Println(&quot;returned result.&quot;)</span><br><span class="line">		retCh &lt;- ret</span><br><span class="line">		fmt.Println(&quot;service exited.&quot;)</span><br><span class="line">	&#125;()</span><br><span class="line">	return retCh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestSelect(t *testing.T) &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	case ret := &lt;-AsyncService():</span><br><span class="line">		t.Log(ret)</span><br><span class="line">	case &lt;-time.After(time.Millisecond * 100):</span><br><span class="line">		t.Error(&quot;time out&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="channel-de-guan-bi"><span id="channel-de-guan-bi"><code>channel</code>的关闭</span><a href="#channel-de-guan-bi" class="header-anchor">#</a></h3><ul>
<li>向关闭的<code>channel</code>发送数据，会导致<code>panic</code></li>
<li><code>v, ok &lt;-ch</code>为<code>bool</code>值,<code>true</code>表示正常接受，<code>false</code>表通道关闭</li>
<li>所有的<code>channel</code>接收者都会在<code>channel</code>关闭时，立即从阻塞等待中返回且上述<code>ok</code>值为<code>false</code>。这个广播机制常被利用，进行向多个订阅者同时发送信号。<blockquote>
<p>如：退出信号</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">waitGroup 保证协程运行完（防止程序执行完毕，协程还没执行的尴尬境地）</span><br><span class="line">*/</span><br><span class="line">func dataProducer(ch chan int, wg *sync.WaitGroup) &#123;</span><br><span class="line">	go func() &#123;</span><br><span class="line">		for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">			count := rand.Intn(1000)</span><br><span class="line">			time.Sleep(time.Millisecond * time.Duration(count))</span><br><span class="line">			ch &lt;- i</span><br><span class="line"></span><br><span class="line">			fmt.Println(&quot;发的时间&quot;, time.Now())</span><br><span class="line">		&#125;</span><br><span class="line">		close(ch)</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func dataReceiver(ch chan int, wg *sync.WaitGroup) &#123;</span><br><span class="line">	//go func() &#123;</span><br><span class="line">	//	for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">	//		if data, ok := &lt;-ch; ok &#123;</span><br><span class="line">	//			fmt.Println(data)</span><br><span class="line">	//		&#125; else &#123;</span><br><span class="line">	//			break</span><br><span class="line">	//		&#125;</span><br><span class="line">	//	&#125;</span><br><span class="line">	//	wg.Done()</span><br><span class="line">	//&#125;()</span><br><span class="line">	go func() &#123;</span><br><span class="line">		for &#123;</span><br><span class="line">			if data, ok := &lt;-ch; ok &#123;</span><br><span class="line">				fmt.Println(&quot;收的时间&quot;, time.Now())</span><br><span class="line">				fmt.Println(data)</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				break</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestCloseChannel(t *testing.T) &#123;</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	ch := make(chan int)</span><br><span class="line">	wg.Add(1)</span><br><span class="line">	dataProducer(ch, &amp;wg)</span><br><span class="line">	wg.Add(1)</span><br><span class="line">	dataReceiver(ch, &amp;wg)</span><br><span class="line">	//wg.Add(1)</span><br><span class="line">	//dataReceiver(ch, &amp;wg)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ren-wu-qu-xiao"><span id="ren-wu-qu-xiao">任务取消</span><a href="#ren-wu-qu-xiao" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 多路复用</span><br><span class="line">func isCancelled(ch chan struct&#123;&#125;) bool &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	case &lt;-ch:</span><br><span class="line">		return true</span><br><span class="line">	default:</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func cancel_1(cancelChan chan struct&#123;&#125;) &#123;</span><br><span class="line">	cancelChan &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func cancel_2(cancelChan chan struct&#123;&#125;) &#123;</span><br><span class="line">	close(cancelChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestCancel(t *testing.T) &#123;</span><br><span class="line">	cancelChan := make(chan struct&#123;&#125;, 0)</span><br><span class="line">	for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">		go func(i int, cancelCh chan struct&#123;&#125;) &#123;</span><br><span class="line">			for &#123;</span><br><span class="line">				if isCancelled(cancelCh) &#123;</span><br><span class="line">					break</span><br><span class="line">				&#125;</span><br><span class="line">				time.Sleep(time.Millisecond * 5)</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(i, &quot;Done&quot;)</span><br><span class="line">		&#125;(i, cancelChan)</span><br><span class="line">	&#125;</span><br><span class="line">	cancel_2(cancelChan)</span><br><span class="line">	time.Sleep(time.Second * 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="context-yu-ren-wu-qu-xiao"><span id="context-yu-ren-wu-qu-xiao">Context 与 任务取消</span><a href="#context-yu-ren-wu-qu-xiao" class="header-anchor">#</a></h3><p><img src="https://s2.loli.net/2022/08/26/HD8vRkT1oZhIq7A.png" alt="image.png"></p>
<h4 id="context"><span id="context">Context</span><a href="#context" class="header-anchor">#</a></h4><ul>
<li>根<code>Context</code>：通过<code>context.Background()</code>创建</li>
<li>子<code>Context</code>：<code>context.WithCancel(parentContext)</code>创建</li>
</ul>
<p><code>ctx, cancel := context.WithCancel(context.Background())</code></p>
<blockquote>
<p><code>cancel</code>是一个方法</p>
</blockquote>
<ul>
<li>当前<code>Context</code>被取消时，基于他的子<code>context</code>都会被取消</li>
<li>接收取消通知 <code>&lt;-ctx.Done</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func isCancelled(ctx context.Context) bool &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	case &lt;-ctx.Done():</span><br><span class="line">		return true</span><br><span class="line">	default:</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestCancelCloseByContext(t *testing.T) &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">		go func(i int, ctx context.Context) &#123;</span><br><span class="line">			for &#123;</span><br><span class="line">				if isCancelled(ctx) &#123;</span><br><span class="line">					break</span><br><span class="line">				&#125;</span><br><span class="line">				time.Sleep(time.Millisecond * 5)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			fmt.Println(i, &quot;Cancelled&quot;)</span><br><span class="line">		&#125;(i, ctx)</span><br><span class="line">	&#125;</span><br><span class="line">	cancel()</span><br><span class="line">	time.Sleep(time.Second * 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="zhi-yun-xing-yi-ci"><span id="zhi-yun-xing-yi-ci">只运行一次</span><a href="#zhi-yun-xing-yi-ci" class="header-anchor">#</a></h3><h4 id="dan-li-mo-shi-lan-han-shi-xian-cheng-an-quan"><span id="dan-li-mo-shi-lan-han-shi-xian-cheng-an-quan">单例模式 （懒汉式，线程安全）</span><a href="#dan-li-mo-shi-lan-han-shi-xian-cheng-an-quan" class="header-anchor">#</a></h4><ul>
<li>使用<code>Once</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type Singleton struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var singleInstance *Singleton</span><br><span class="line"></span><br><span class="line">var once sync.Once</span><br><span class="line"></span><br><span class="line">func GetSingletonObj() *Singleton &#123;</span><br><span class="line">	once.Do(func() &#123;</span><br><span class="line">		fmt.Println(&quot;Create obj&quot;)</span><br><span class="line">		singleInstance = new(Singleton)</span><br><span class="line">	&#125;)</span><br><span class="line">	return singleInstance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestSingletonObj(t *testing.T) &#123;</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			obj := GetSingletonObj()</span><br><span class="line">			fmt.Printf(&quot;%p\n&quot;, obj)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="jin-xu-ren-yi-ren-wu-wan-cheng"><span id="jin-xu-ren-yi-ren-wu-wan-cheng">仅需任意任务完成</span><a href="#jin-xu-ren-yi-ren-wu-wan-cheng" class="header-anchor">#</a></h3><blockquote>
<p>利用<code>buffered channel</code>的机制（容量满了才会阻塞），解决&#x3D;&#x3D;无缓存<code>channel</code>&#x3D;&#x3D;阻塞，导致协程无法释放，最后引起<code>Memory Leak</code>问题</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func runTask(id int) string &#123;</span><br><span class="line">	time.Sleep(10 * time.Millisecond)</span><br><span class="line">	return fmt.Sprintf(&quot;The result is from %d&quot;, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func FirstResponse() string &#123;</span><br><span class="line">	numberOfRunner := 10</span><br><span class="line">	ch := make(chan string, numberOfRunner)</span><br><span class="line">	for i := 0; i &lt; numberOfRunner; i++ &#123;</span><br><span class="line">		go func(i int) &#123;</span><br><span class="line">			ret := runTask(i)</span><br><span class="line">			ch &lt;- ret</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	return &lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestFistResponse(t *testing.T) &#123;</span><br><span class="line">	t.Log(&quot;Before:&quot;, runtime.NumGoroutine())</span><br><span class="line">	t.Log(FirstResponse())</span><br><span class="line">	time.Sleep(time.Second * 1)</span><br><span class="line">	t.Log(&quot;After:&quot;, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="suo-you-ren-wu-wan-cheng"><span id="suo-you-ren-wu-wan-cheng">所有任务完成</span><a href="#suo-you-ren-wu-wan-cheng" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func runTask(id int) string &#123;</span><br><span class="line">	time.Sleep(time.Millisecond * 10)</span><br><span class="line">	return fmt.Sprintf(&quot;The result is from %d&quot;, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func AllResponse() string &#123;</span><br><span class="line">	numberOfRunner := 10</span><br><span class="line">	ch := make(chan string, numberOfRunner)</span><br><span class="line">	//ch := make(chan string)</span><br><span class="line">	res := &quot;&quot;</span><br><span class="line">	for i := 0; i &lt; numberOfRunner; i++ &#123;</span><br><span class="line">		go func(i int) &#123;</span><br><span class="line">			ret := runTask(i)</span><br><span class="line">			ch &lt;- ret</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	for i := 0; i &lt; numberOfRunner; i++ &#123;</span><br><span class="line">		res += &lt;-ch + &quot;\n&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestAllResponse(t *testing.T) &#123;</span><br><span class="line">	t.Log(&quot;Before:&quot;, runtime.NumGoroutine())</span><br><span class="line">	t.Log(AllResponse())</span><br><span class="line">	time.Sleep(time.Second * 1)</span><br><span class="line">	t.Log(&quot;After:&quot;, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="dui-xiang-chi"><span id="dui-xiang-chi">对象池</span><a href="#dui-xiang-chi" class="header-anchor">#</a></h3><p><img src="https://s2.loli.net/2022/08/26/pcKrhRCaEblxnHX.png" alt="image.png"></p>
<blockquote>
<p>使用不同的池缓冲不同的对象<br><strong>Pool Example</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">type ReusableObj struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ObjPool struct &#123;</span><br><span class="line">	bufChan chan *ReusableObj // 用于缓冲可重用对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewObjPool(numberOfObj int) *ObjPool &#123;</span><br><span class="line">	objPool := ObjPool&#123;&#125;</span><br><span class="line">	objPool.bufChan = make(chan *ReusableObj, 10)</span><br><span class="line">	for i := 0; i &lt; numberOfObj; i++ &#123;</span><br><span class="line">		objPool.bufChan &lt;- &amp;ReusableObj&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return &amp;objPool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *ObjPool) GetObj(timeout time.Duration) (*ReusableObj, error) &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	case ret := &lt;-p.bufChan:</span><br><span class="line">		return ret, nil</span><br><span class="line">	case &lt;-time.After(timeout): // 超时控制</span><br><span class="line">		return nil, errors.New(&quot;time out&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *ObjPool) ReleaseObj(obj *ReusableObj) error &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	case p.bufChan &lt;- obj:</span><br><span class="line">		return nil</span><br><span class="line">	default:</span><br><span class="line">		return errors.New(&quot;overflow&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>use Example</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func TestObjPool(t *testing.T) &#123;</span><br><span class="line">	pool := NewObjPool(10)</span><br><span class="line">	if err := pool.ReleaseObj(&amp;ReusableObj&#123;&#125;); err != nil &#123; // 溢出</span><br><span class="line">		t.Log(err)</span><br><span class="line">	&#125;</span><br><span class="line">	for i := 0; i &lt; 11; i++ &#123;</span><br><span class="line">		if v, err := pool.GetObj(time.Second * 1); err != nil &#123;</span><br><span class="line">			t.Error(err)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			fmt.Printf(&quot;%T\n&quot;, v)</span><br><span class="line">			if err := pool.ReleaseObj(v); err != nil &#123;</span><br><span class="line">				t.Error(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;Done&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="sync-pool-dui-xiang-huan-cun"><span id="sync-pool-dui-xiang-huan-cun"><code>sync.Pool</code>对象缓存</span><a href="#sync-pool-dui-xiang-huan-cun" class="header-anchor">#</a></h3><h4 id="sync-pool-dui-xiang-huo-qu"><span id="sync-pool-dui-xiang-huo-qu"><code>sync.Pool</code>对象获取</span><a href="#sync-pool-dui-xiang-huo-qu" class="header-anchor">#</a></h4><ul>
<li>尝试从私有对象获取</li>
<li>私有对象不存在，尝试从当前<code>Processor</code>的共享池获取</li>
<li>如果当前<code>Processor</code>共享池也是空的，那么就尝试去其他<code>Processor</code>的共享池获取</li>
<li>如果所有子池都是空的，最后就用用户指定的<code>New</code>函数产生一个新的对象返回</li>
<li><img src="https://s2.loli.net/2022/08/26/JlEByR3cqmUoWph.png" alt="image.png"><blockquote>
<p>协程安全 既没有锁，有锁便是协程不安全</p>
</blockquote>
</li>
</ul>
<h4 id="sync-pool-dui-xiang-de-fan-hui"><span id="sync-pool-dui-xiang-de-fan-hui"><code>sync.Pool</code>对象的返回</span><a href="#sync-pool-dui-xiang-de-fan-hui" class="header-anchor">#</a></h4><ul>
<li>如果私有对象不存在则保存为私有对象</li>
<li>如果私有对象蹲在，放入当前<code>Processor</code>子池的共享池</li>
</ul>
<h4 id="shi-yong-sync-pool"><span id="shi-yong-sync-pool">使用<code>sync.Pool</code></span><a href="#shi-yong-sync-pool" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pool := &amp;sync.Pool&#123;</span><br><span class="line">    New: func() interface&#123;&#125; &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array := pool.Get().(int)</span><br><span class="line">    ...</span><br><span class="line">pool.Put(10)</span><br></pre></td></tr></table></figure>

<h4 id="sync-pool-dui-xiang-de-sheng-ming-zhou-qi"><span id="sync-pool-dui-xiang-de-sheng-ming-zhou-qi"><code>sync.Pool</code>对象的生命周期</span><a href="#sync-pool-dui-xiang-de-sheng-ming-zhou-qi" class="header-anchor">#</a></h4><ul>
<li><code>GC</code>会清楚<code>sync.pool</code>缓存的对象</li>
<li>对象的缓存有效期为下一次<code>GC</code>之前</li>
</ul>
<h4 id="sync-pool-zong-jie"><span id="sync-pool-zong-jie"><code>sync.Pool</code>总结</span><a href="#sync-pool-zong-jie" class="header-anchor">#</a></h4><ul>
<li>适合于通过复用、降低复杂对象得创建和GC代价</li>
<li>协程安全.&#x3D;&#x3D;会有锁的开销&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;生命周期受GC影响，不适合于做连接池等，需自己管理生命周期的资源的池化&#x3D;&#x3D;<blockquote>
<p>是锁的开销大 与 创建对象得开销大，决定 <code>sync.Pool</code>是否带来性能优化得功效</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">func TestSyncPool(t *testing.T) &#123;</span><br><span class="line">	pool := &amp;sync.Pool&#123;</span><br><span class="line">		New: func() interface&#123;&#125; &#123;</span><br><span class="line">			fmt.Println(&quot;Create a new object.&quot;)</span><br><span class="line">			return 100</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	v := pool.Get().(int)</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">	pool.Put(3)</span><br><span class="line">	runtime.GC() // GC 会清除sync.pool 中缓存的对象</span><br><span class="line">	v1, _ := pool.Get().(int)</span><br><span class="line">	fmt.Println(v1)</span><br><span class="line">	v2, _ := pool.Get().(int)</span><br><span class="line">	fmt.Println(v2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestSyncPoolInMultiGroutine(t *testing.T) &#123;</span><br><span class="line">	pool := &amp;sync.Pool&#123;</span><br><span class="line">		New: func() interface&#123;&#125; &#123;</span><br><span class="line">			fmt.Println(&quot;Create a new object.&quot;)</span><br><span class="line">			return 10</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pool.Put(100)</span><br><span class="line">	pool.Put(100)</span><br><span class="line">	pool.Put(100)</span><br><span class="line"></span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func(id int) &#123;</span><br><span class="line">			//t.Log(pool.Get())</span><br><span class="line">			fmt.Println(pool.Get())</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="go-zhong-de-mian-xiang-dui-xiang"><span id="go-zhong-de-mian-xiang-dui-xiang">Go中的面向对象</span><a href="#go-zhong-de-mian-xiang-dui-xiang" class="header-anchor">#</a></h2><h3 id="feng-zhuang-shu-ju-he-xing-wei"><span id="feng-zhuang-shu-ju-he-xing-wei">封装数据和行为</span><a href="#feng-zhuang-shu-ju-he-xing-wei" class="header-anchor">#</a></h3><blockquote>
<p>Go中的接口使用Duck Type（鸭子类型）设计类型</p>
</blockquote>
<h4 id="jie-gou-ti-ding-yi"><span id="jie-gou-ti-ding-yi">结构体定义</span><a href="#jie-gou-ti-ding-yi" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Employee struct&#123;</span><br><span class="line">    Id string</span><br><span class="line">    Name string</span><br><span class="line">    Age int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体创建及初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">e := Employee&#123;&quot;0&quot;, &quot;Bob&quot;, 20&#125;</span><br><span class="line">e1 := Employee&#123;Name: &quot;Mike&quot;, Age: 30&#125;</span><br><span class="line">e2 := new(Employee) // 注意这里返回的引用/指针，相当于 e := &amp;Employee&#123;&#125;</span><br><span class="line">e2.Id = &quot;2&quot; // 与其他主要编程语言的差异：通过实例的指针访问成员不需要试用-&gt;</span><br><span class="line">e2.Age = 22</span><br><span class="line">e2.Name = &quot;Rose&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>行为（方法）定义</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (e Employee) String() string &#123;</span><br><span class="line">	return fmt.Sprintf(&quot;ID:%s-Name:%s-Age:%d&quot;, e.Id, e.Name, e.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一种定义方式在实例对应方法被调用时，实例的成员会进行值复制</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (e *Employee) String() string &#123;</span><br><span class="line">	return fmt.Sprintf(&quot;ID:%s-Name:%s-Age:%d&quot;, e.Id, e.Name, e.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常情况下为了避免内存拷贝，会是使用上面这种定义方式</p>
</blockquote>
<h3 id="duck-type-shi-jie-kou-shi-xian"><span id="duck-type-shi-jie-kou-shi-xian"><code>Duck Type</code>式接口实现</span><a href="#duck-type-shi-jie-kou-shi-xian" class="header-anchor">#</a></h3><p><strong>接口定义</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">interface</span> &#123;</span><br><span class="line">	WriteHelloWorld() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口实现</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GoProgrammer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GoProgrammer)</span></span> WriteHelloWorld() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;fmt.Println(\&quot;Hello World\&quot;)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>接口实现检测</strong></p>
<blockquote>
<p>编译期就检查接口是否实现（<code>Golang</code>直接会显示错误，如果没实现），不用等在使用时候才检测</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ GoProgrammer = (*Programmer)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<h4 id="go-jie-kou-yu-qi-ta-zhu-liu-bian-cheng-yu-yan-de-chai-yi"><span id="go-jie-kou-yu-qi-ta-zhu-liu-bian-cheng-yu-yan-de-chai-yi">Go接口与其他主流编程语言的差异</span><a href="#go-jie-kou-yu-qi-ta-zhu-liu-bian-cheng-yu-yan-de-chai-yi" class="header-anchor">#</a></h4><ol>
<li>接口为非入侵性，实现不依赖于接口定义</li>
<li>所以接口的定义可以包含在接口使用者的包内（不会产生循环依赖）<br><img src="https://s2.loli.net/2022/08/26/ApTV4Gn8ZhrXxjO.png" alt="image.psd.png"></li>
</ol>
<h4 id="zi-ding-yi-lei-xing"><span id="zi-ding-yi-lei-xing">自定义类型</span><a href="#zi-ding-yi-lei-xing" class="header-anchor">#</a></h4><ol>
<li><code>type IntCovertionFn func(n int) int</code></li>
<li><code>type MyPoint int</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntConv <span class="function"><span class="keyword">func</span><span class="params">(op <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeSpent</span><span class="params">(inner IntConv)</span></span> IntConv &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(op <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		start := time.Now()</span><br><span class="line">		ret := inner(op)</span><br><span class="line">		fmt.Println(<span class="string">&quot;time spent:&quot;</span>, time.Since(start).Seconds())</span><br><span class="line">		<span class="keyword">return</span> ret</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slowFn</span><span class="params">(op <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> op</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSlowFn</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	fn := timeSpent(slowFn)</span><br><span class="line">	t.Log(fn(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="kuo-zhan-yu-fu-yong"><span id="kuo-zhan-yu-fu-yong">扩展与复用</span><a href="#kuo-zhan-yu-fu-yong" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">type Pet struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Pet) Speak() &#123;</span><br><span class="line">	fmt.Print(&quot;...&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Pet) SpeakTo(host string) &#123;</span><br><span class="line">	p.Speak()</span><br><span class="line">	fmt.Println(&quot; &quot;, host)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Dog struct &#123;</span><br><span class="line">	//p *Pet</span><br><span class="line">	Pet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//func (d *Dog) Speak() &#123;</span><br><span class="line">//	//d.p.Speak()</span><br><span class="line">//	fmt.Print(&quot;Wang!&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (d *Dog) SpeakTo(host string) &#123;</span><br><span class="line">//	//d.p.SpeakTo(host)</span><br><span class="line">//	d.Speak()</span><br><span class="line">//	fmt.Println(&quot; &quot;, host)</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">func (d *Dog) Speak() &#123;</span><br><span class="line">	fmt.Println(&quot;Wang!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestDog(t *testing.T) &#123;</span><br><span class="line">	dog := new(Dog)</span><br><span class="line">	dog.SpeakTo(&quot;Chao&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="duo-tai"><span id="duo-tai">多态</span><a href="#duo-tai" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">type Code string</span><br><span class="line"></span><br><span class="line">type Programmer interface &#123;</span><br><span class="line">	WriteHelloWorld() Code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type GoProgrammer struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *GoProgrammer) WriteHelloWorld() Code &#123;</span><br><span class="line">	return &quot;fmt.Println(\&quot;Hello World!\&quot;)&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type JavaProgrammer struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *JavaProgrammer) WriteHelloWorld() Code &#123;</span><br><span class="line">	return &quot;System.out.Println(\&quot;Hello World\&quot;)&quot;</span><br><span class="line">&#125;</span><br><span class="line">func writeFirstProgram(p Programmer) &#123;</span><br><span class="line">	fmt.Printf(&quot;%T %v\n\n&quot;, p, p.WriteHelloWorld())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestPolymorphism(t *testing.T) &#123;</span><br><span class="line">	goProg := new(GoProgrammer)</span><br><span class="line">	goProg2 := &amp;GoProgrammer&#123;&#125;</span><br><span class="line">	javaProg := new(JavaProgrammer)</span><br><span class="line">	writeFirstProgram(goProg)</span><br><span class="line">	writeFirstProgram(javaProg)</span><br><span class="line">	writeFirstProgram(goProg2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kong-jie-kou-yu-duan-yan"><span id="kong-jie-kou-yu-duan-yan">空接口与断言</span><a href="#kong-jie-kou-yu-duan-yan" class="header-anchor">#</a></h3><ol>
<li>空接口可以表示&#x3D;&#x3D;任何类型&#x3D;&#x3D;</li>
<li>通过断言来将空接口转换为制定类型<br><code>v,ok := p.(int) // ok=true时为转换成功</code><blockquote>
<p>断言用法： <code>*.(type)</code>中的<code>.()</code>是格式<code>type</code>是被断言的类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func DoSomething(p interface&#123;&#125;) &#123;</span><br><span class="line">	//if i, ok := p.(int); ok &#123; // 这是断言</span><br><span class="line">	//	fmt.Println(&quot;Interger&quot;, i)</span><br><span class="line">	//	return</span><br><span class="line">	//&#125;</span><br><span class="line">	//if s, ok := p.(string); ok &#123;</span><br><span class="line">	//	fmt.Println(&quot;string&quot;, s)</span><br><span class="line">	//	return</span><br><span class="line">	//&#125;</span><br><span class="line">	//fmt.Println(&quot;Unknow Type&quot;)</span><br><span class="line">	switch v := p.(type) &#123;</span><br><span class="line">	case int:</span><br><span class="line">		fmt.Println(&quot;Integer&quot;, v)</span><br><span class="line">	case string:</span><br><span class="line">		fmt.Println(&quot;string&quot;, v)</span><br><span class="line">	default:</span><br><span class="line">		fmt.Println(&quot;Unknow Type&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestEmptyInterfaceAssertion(t *testing.T) &#123;</span><br><span class="line">	DoSomething(10)</span><br><span class="line">	DoSomething(&quot;10&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="https://s2.loli.net/2022/08/26/h2TemGObdNPWp7A.png" alt="image.psd.png"></p>
<h2 id="ce-shi"><span id="ce-shi">测试</span><a href="#ce-shi" class="header-anchor">#</a></h2><h3 id="ce-shi-testing"><span id="ce-shi-testing">测试<code>testing</code></span><a href="#ce-shi-testing" class="header-anchor">#</a></h3><ol>
<li>源码文件以<code>_test</code>结尾：<code>xxx_test.go</code></li>
<li>测试文件名以<code>Test</code>开头：<code>func TestXXX(t *testing.T)&#123;...&#125;</code><blockquote>
<p>大写的方法代表&#x3D;&#x3D;包外&#x3D;&#x3D;<strong>可以访问</strong></p>
</blockquote>
</li>
</ol>
<h3 id="dan-yuan-ce-shi"><span id="dan-yuan-ce-shi">单元测试</span><a href="#dan-yuan-ce-shi" class="header-anchor">#</a></h3><h4 id="biao-ge-ce-shi-fa"><span id="biao-ge-ce-shi-fa">表格测试法</span><a href="#biao-ge-ce-shi-fa" class="header-anchor">#</a></h4><blockquote>
<p>准备一组输入组合，对期待值组合进行一对一比较</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func square(op int) int &#123;</span><br><span class="line">	return op * op</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestSquare(t *testing.T) &#123;</span><br><span class="line">	inputs := [...]int&#123;1, 2, 3&#125;</span><br><span class="line">	expected := [...]int&#123;1, 4, 9&#125;</span><br><span class="line">	for i := 0; i &lt; len(inputs); i++ &#123;</span><br><span class="line">		ret := square(inputs[i])</span><br><span class="line">		if ret != expected[i] &#123;</span><br><span class="line">			t.Errorf(&quot;input is %d, the expected is %d, the actual %d&quot;,</span><br><span class="line">				inputs[i], expected[i], ret)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="nei-zhi-dan-yuan-ce-shi-kuang-jia"><span id="nei-zhi-dan-yuan-ce-shi-kuang-jia">内置单元测试框架</span><a href="#nei-zhi-dan-yuan-ce-shi-kuang-jia" class="header-anchor">#</a></h4><ul>
<li><code>Fail</code>,<code>Error</code>：该测试失败，该此时继续，其他测试继续执行</li>
<li><code>FailNow</code>,<code>Fatal</code>：该测试失败，该测试中止，其他测继续执行</li>
<li>代码覆盖率<br><code>go test -v -cover</code><blockquote>
<p><code>cover</code> 代表全覆盖</p>
</blockquote>
</li>
<li>断言<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/stretchr/testify">https://github.com/stretchr/testify</a></p>
</blockquote>
</li>
</ul>
<h4 id="benchmark"><span id="benchmark">BenchMark</span><a href="#benchmark" class="header-anchor">#</a></h4><blockquote>
<p>代码片段测评</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkConcatStringByAdd(b *testing.B) &#123;</span><br><span class="line">	elems := []string&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;&#125;</span><br><span class="line">	ret := &quot;&quot;</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">		for _, elem := range elems &#123;</span><br><span class="line">			ret += elem</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	b.StopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkConcatStringBytesBuffer(b *testing.B) &#123;</span><br><span class="line">	var buf bytes.Buffer</span><br><span class="line">	elems := []string&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;&#125;</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">		for _, elem := range elems &#123;</span><br><span class="line">			buf.WriteString(elem)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	b.StopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>go test -bench=. -benchmem</code></p>
<blockquote>
<p><code>-bench</code>&#x3D;&lt;相关benchmark测试&gt;<br>window下使用<code>go test</code>命令行时，<code>-bench=.</code>应写为<code>-bench=&quot;.&quot;</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">go test -bench=&quot;.&quot; -benchmem</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: testingOperation/unitTest</span><br><span class="line">cpu: AMD Ryzen 7 3700X 8-Core Processor</span><br><span class="line">BenchmarkConcatStringByAdd-16           10998074               108.9 ns/op            16 B/op          4 allocs/op</span><br><span class="line">BenchmarkConcatStringBytesBuffer-16     25526863                48.09 ns/op           64 B/op          1 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      testingOperation/unitTest       2.721s</span><br></pre></td></tr></table></figure>

<ul>
<li><code>16</code>: 表示允许时对应的<code>GOMAXPROCS</code>的值</li>
<li><code>10998074</code>: 表示运行<code>for</code>循环的次数，也就是调用被测试代码的次数，也就是<code>b.N</code>的范围内执行的次数</li>
<li><code>108.9 ns/op</code>：表示平均每次需要花费<code>108.9</code>纳秒</li>
<li><code>allocs/op</code>：表示每个参数（单次迭代）发生了多少不同的内存分配</li>
<li><code>B/op</code>: 每个操作分配了多少字节</li>
</ul>
<h3 id="bdd"><span id="bdd">BDD</span><a href="#bdd" class="header-anchor">#</a></h3><blockquote>
<p>Behavior Driven Development<br><img src="https://s2.loli.net/2022/08/26/w6N1ziUqLBxE7rv.png" alt="image.psd.png"></p>
</blockquote>
<p><strong>项目网站</strong>：<a target="_blank" rel="noopener" href="https://github.com/smartystreets/goconvey">https://github.com/smartystreets/goconvey</a></p>
<p><strong>安装</strong><br><code>go get -u github.com/smartystreets/goconvey/convey</code></p>
<p><strong>启动 <code>WEB UI</code></strong><br><code>$GOPATH/bin/goconvey</code></p>
<blockquote>
<p>需要完整安装<br><code>go get -u github.com/smartystreets/goconvey</code></p>
</blockquote>
<h2 id="fan-she-bian-cheng"><span id="fan-she-bian-cheng">反射编程</span><a href="#fan-she-bian-cheng" class="header-anchor">#</a></h2><h3 id="reflect-typeof-vs-reflect-valueof"><span id="reflect-typeof-vs-reflect-valueof"><code>reflect.TypeOf vs reflect.ValueOf</code></span><a href="#reflect-typeof-vs-reflect-valueof" class="header-anchor">#</a></h3><ul>
<li><code>reflect.TypeOf</code>返回类型(reflect.Type)</li>
<li><code>reflect.ValueOf</code>返回值(reflect.Value)</li>
<li>可以从<code>reflect.Value</code>获得类型</li>
<li>通过<code>kind</code>的来判断类型</li>
</ul>
<h4 id="pan-duan-lei-xing-kind"><span id="pan-duan-lei-xing-kind">判断类型-<code>kind()</code></span><a href="#pan-duan-lei-xing-kind" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    Invalid Kind = iota</span><br><span class="line">    Bool</span><br><span class="line">    Int</span><br><span class="line">    Int8</span><br><span class="line">    Int16</span><br><span class="line">    Int32</span><br><span class="line">    Int64</span><br><span class="line">    Uint</span><br><span class="line">    Uint8</span><br><span class="line">    Uint16</span><br><span class="line">    Uint32</span><br><span class="line">    Uint64</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="li-yong-fan-she-bian-xie-ling-huo-de-dai-ma"><span id="li-yong-fan-she-bian-xie-ling-huo-de-dai-ma">利用反射编写灵活的代码</span><a href="#li-yong-fan-she-bian-xie-ling-huo-de-dai-ma" class="header-anchor">#</a></h3><p><strong>按名字访问结构的成员</strong><br><code>reflect.ValueOf(*e).FieldByName(&quot;Name&quot;)</code></p>
<p><strong>按名字访问结构的方法</strong><br><code>reflect.ValueOf(e).MethodByName(&quot;UpdateAge&quot;).Call([]reflect.ValueOf(1))</code></p>
<h3 id="struct-tag"><span id="struct-tag">Struct Tag</span><a href="#struct-tag" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type BasicInfo struct &#123;</span><br><span class="line">    Name string `json:&quot;name&quot;`</span><br><span class="line">    Age int `json:&quot;age&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>string 与 int 后面的结构就是 <code>Struct Tag</code> 用法</p>
</blockquote>
<h4 id="struct-tag-de-ke-xuan-zi-duan"><span id="struct-tag-de-ke-xuan-zi-duan"><code>struct tag</code>的可选字段</span><a href="#struct-tag-de-ke-xuan-zi-duan" class="header-anchor">#</a></h4><p>Tag可选的字段：</p>
<ul>
<li><code>&quot;-&quot;</code> ：不要解析这个字段</li>
<li><code>&quot;omitempty&quot;</code>：当字段为空(默认值)时,不要解析这个字段；比如是<code>false、0、nil</code>或者长度为<code>0</code>的<code>array、map、slice、string</code>等</li>
<li><code>FieldName</code>：当解析<code>json、xml、ini</code>等的时候 用这个名字</li>
</ul>
<h4 id="fang-wen-struct-tag"><span id="fang-wen-struct-tag">访问<code>Struct Tag</code></span><a href="#fang-wen-struct-tag" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if nameField, ok := reflect.TypeOf(*r).FiledName(&quot;Name&quot;); !ok &#123;</span><br><span class="line">    t.Error(&quot;Failed to get &#x27;Name&#x27; field.&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    t.Log(&quot;Tag:format&quot;, nameField.Tag.Get(&quot;format&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Reflect.Type</code>和<code>Reflect.Value</code>都有<code>FieldByName</code>方法，注意区分</p>
</blockquote>
<h3 id="deepequal-bi-jiao-map-he-qie-pian"><span id="deepequal-bi-jiao-map-he-qie-pian">DeepEqual 比较<code>Map</code>和切片</span><a href="#deepequal-bi-jiao-map-he-qie-pian" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func TestDeepEqual(t *testing.T) &#123;</span><br><span class="line">	a := map[int]string&#123;1: &quot;one&quot;, 2: &quot;two&quot;, 3: &quot;three&quot;&#125;</span><br><span class="line">	b := map[int]string&#123;1: &quot;one&quot;, 2: &quot;two&quot;, 4: &quot;three&quot;&#125;</span><br><span class="line">	//t.Log(a == b)</span><br><span class="line">	t.Log(reflect.DeepEqual(a, b))</span><br><span class="line"></span><br><span class="line">	s1 := []int&#123;1, 2, 3&#125;</span><br><span class="line">	s2 := []int&#123;1, 2, 3&#125;</span><br><span class="line">	s3 := []int&#123;2, 3, 1&#125;</span><br><span class="line">	t.Log(&quot;s1 == s2?&quot;, reflect.DeepEqual(s1, s2))</span><br><span class="line">	t.Log(&quot;s1 == s3?&quot;, reflect.DeepEqual(s1, s3))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="wan-neng-cheng-xu"><span id="wan-neng-cheng-xu">万能程序</span><a href="#wan-neng-cheng-xu" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">type Employee1 struct &#123;</span><br><span class="line">	EmployeeID string</span><br><span class="line">	Name       string `format:&quot;normal&quot;`</span><br><span class="line">	Age        int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *Employee1) UpdateAge(newVal int) &#123;</span><br><span class="line">	e.Age = newVal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Customer1 struct &#123;</span><br><span class="line">	CookieID string</span><br><span class="line">	Name     string</span><br><span class="line">	Age      int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func fillBySettings(st interface&#123;&#125;, settings map[string]interface&#123;&#125;) error &#123;</span><br><span class="line">	if reflect.TypeOf(st).Kind() != reflect.Ptr &#123;</span><br><span class="line">		// Elem() 获取指针指向的值</span><br><span class="line">		if reflect.TypeOf(st).Elem().Kind() != reflect.Struct &#123;</span><br><span class="line">			return errors.New(&quot;the first param should be a pointer to struct type&quot;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if settings == nil &#123;</span><br><span class="line">		return errors.New(&quot;settings is nil&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var (</span><br><span class="line">		field reflect.StructField</span><br><span class="line">		ok    bool</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	for k, v := range settings &#123;</span><br><span class="line">		if field, ok = (reflect.ValueOf(st)).Elem().Type().FieldByName(k); !ok &#123;</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(k, reflect.TypeOf(k), field, field.Type, v, reflect.TypeOf(v))</span><br><span class="line">		if field.Type == reflect.TypeOf(v) &#123;</span><br><span class="line">			vstr := reflect.ValueOf(st)</span><br><span class="line">			vstr.Elem().FieldByName(k).Set(reflect.ValueOf(v))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestFillNameAndAge(t *testing.T) &#123;</span><br><span class="line">	settings := map[string]interface&#123;&#125;&#123;&quot;Name&quot;: &quot;Mike&quot;, &quot;Age&quot;: 40&#125;</span><br><span class="line">	e := Employee1&#123;&#125;</span><br><span class="line">	if err := fillBySettings(e, settings); err != nil &#123;</span><br><span class="line">		t.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	t.Log(e)</span><br><span class="line">	c := new(Customer1)</span><br><span class="line">	if err := fillBySettings(c, settings); err != nil &#123;</span><br><span class="line">		t.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	t.Log(*c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fan-she-bi-yao-liao-jie"><span id="fan-she-bi-yao-liao-jie">反射必要了解</span><a href="#fan-she-bi-yao-liao-jie" class="header-anchor">#</a></h3><ul>
<li>提供了程序灵活性</li>
<li>降低了程序的可读性</li>
<li>降低了程序的性能<blockquote>
<p>反射进阶了解：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/AyxkaR-Qu2PV85zZCXBRVA">https://mp.weixin.qq.com/s/AyxkaR-Qu2PV85zZCXBRVA</a></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>Go语言反射的实现原理：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU5NTAzNjc3Mg==&amp;mid=2247483962&amp;idx=1&amp;sn=e13df5c5e016215302205f5ec8fbb857&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzU5NTAzNjc3Mg==&amp;mid=2247483962&amp;idx=1&amp;sn=e13df5c5e016215302205f5ec8fbb857&amp;scene=21#wechat_redirect</a></p>
</blockquote>
<h2 id="bu-an-quan-bian-cheng"><span id="bu-an-quan-bian-cheng">不安全编程</span><a href="#bu-an-quan-bian-cheng" class="header-anchor">#</a></h2><blockquote>
<p>使用<code>C</code>高效库</p>
</blockquote>
<h3 id="bu-an-quan-xing-wei-de-wei-xian-xing"><span id="bu-an-quan-xing-wei-de-wei-xian-xing"><code>不安全</code>行为的危险性</span><a href="#bu-an-quan-xing-wei-de-wei-xian-xing" class="header-anchor">#</a></h3><h4 id="bu-he-li-de-lei-xing-zhuan-huan-qiang-zhi-lei-xing-zhuan-huan"><span id="bu-he-li-de-lei-xing-zhuan-huan-qiang-zhi-lei-xing-zhuan-huan">不合理的类型转换（强制类型转换）</span><a href="#bu-he-li-de-lei-xing-zhuan-huan-qiang-zhi-lei-xing-zhuan-huan" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func TestUnsafe(t *testing.T) &#123;</span><br><span class="line">	i := 10</span><br><span class="line">	f := *(*float64)(unsafe.Pointer(&amp;i))</span><br><span class="line">	t.Log(unsafe.Pointer(&amp;i))</span><br><span class="line">	t.Log(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="he-li-de-lei-xing-zhuan-huan-bie-ming"><span id="he-li-de-lei-xing-zhuan-huan-bie-ming">合理的类型转换（别名）</span><a href="#he-li-de-lei-xing-zhuan-huan-bie-ming" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type MyInt int</span><br><span class="line"></span><br><span class="line">func TestConvert(t *testing.T) &#123;</span><br><span class="line">	a := []int&#123;1, 2, 3, 4&#125;</span><br><span class="line">	b := *(*[]MyInt)(unsafe.Pointer(&amp;a))</span><br><span class="line">	t.Log(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="yuan-zi-lei-xing-de-cao-zuo"><span id="yuan-zi-lei-xing-de-cao-zuo">原子类型的操作</span><a href="#yuan-zi-lei-xing-de-cao-zuo" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">func TestAtomic(t *testing.T) &#123;</span><br><span class="line">	var shareBufPtr unsafe.Pointer</span><br><span class="line">	writeDataFn := func() &#123;</span><br><span class="line">		data := []int&#123;&#125;</span><br><span class="line">		for i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">			data = append(data, i)</span><br><span class="line">		&#125;</span><br><span class="line">		atomic.StorePointer(&amp;shareBufPtr, unsafe.Pointer(&amp;data))</span><br><span class="line">	&#125;</span><br><span class="line">	readDataFm := func() &#123;</span><br><span class="line">		data := atomic.LoadPointer(&amp;shareBufPtr)</span><br><span class="line">		fmt.Println(data, *(*[]int)(data))</span><br><span class="line">	&#125;</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	writeDataFn()</span><br><span class="line">	for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">				writeDataFn()</span><br><span class="line">				time.Sleep(time.Millisecond * 100)</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">				readDataFm()</span><br><span class="line">				time.Sleep(time.Millisecond * 100)</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>channel</code>版本</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">func TestChainAtomic(t *testing.T) &#123;</span><br><span class="line">	//shareBufPtr := make(chan unsafe.Pointer)</span><br><span class="line">	shareBufPtr := make(chan unsafe.Pointer, 1)</span><br><span class="line">	//var shareBufPtr unsafe.Pointer</span><br><span class="line">	writeDataFn := func() &#123;</span><br><span class="line">		var shareBufPointer unsafe.Pointer</span><br><span class="line">		data := []int&#123;&#125;</span><br><span class="line">		for i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">			data = append(data, i)</span><br><span class="line">		&#125;</span><br><span class="line">		atomic.StorePointer(&amp;shareBufPointer, unsafe.Pointer(&amp;data))</span><br><span class="line">		shareBufPtr &lt;- shareBufPointer</span><br><span class="line">		//t.Log(shareBufPtr)</span><br><span class="line">	&#125;</span><br><span class="line">	readDataFm := func() &#123;</span><br><span class="line">		shareBufPointer := &lt;-shareBufPtr</span><br><span class="line">		//t.Log(shareBufPointer)</span><br><span class="line">		data := atomic.LoadPointer(&amp;shareBufPointer)</span><br><span class="line">		fmt.Println(data, *(*[]int)(data))</span><br><span class="line">	&#125;</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	writeDataFn()</span><br><span class="line">	for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">				writeDataFn()</span><br><span class="line">				time.Sleep(time.Millisecond * 100)</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">				readDataFm()</span><br><span class="line">				time.Sleep(time.Millisecond * 100)</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ruan-jian-jia-gou"><span id="ruan-jian-jia-gou">软件架构</span><a href="#ruan-jian-jia-gou" class="header-anchor">#</a></h2><h3 id="pipe-filter-jia-gou"><span id="pipe-filter-jia-gou"><code>Pipe-Filter</code> 架构</span><a href="#pipe-filter-jia-gou" class="header-anchor">#</a></h3><blockquote>
<p>数据处理、数据分析<br><img src="https://s2.loli.net/2022/08/26/xs6vYenmVy1GTAc.png" alt="image.png"></p>
</blockquote>
<ul>
<li>非常适合与数据处理及数据分析系统</li>
<li><code>Filter</code> 封装数据处理的功能</li>
<li>松耦合：<code>Filter</code> 只跟数据（格式）耦合</li>
<li><code>Pipe</code> 用于连接<code>Filter</code>传递数据或者异步处理过程中缓冲数据流进程内同步调用时，<code>pipe</code>演变为数据在方法调用间传递</li>
</ul>
<p><img src="https://s2.loli.net/2022/08/26/6AVYjc8zhFODBJy.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/08/26/1Merj4ZmxzGCqua.png" alt="image.png"></p>
<p>&#x3D;&#x3D;<a target="_blank" rel="noopener" href="https://note.youdao.com/s/5Mz3htjJ">测试源码</a>&#x3D;&#x3D;</p>
<h3 id="shi-xian-micro-kernel-framework"><span id="shi-xian-micro-kernel-framework">实现<code>micro kernel framework</code></span><a href="#shi-xian-micro-kernel-framework" class="header-anchor">#</a></h3><p><strong>特点</strong></p>
<ul>
<li>易于扩展</li>
<li>错误隔离</li>
<li>保持架构一致性</li>
</ul>
<p><strong>要点</strong></p>
<ul>
<li>内核包含公共流程或通用逻辑</li>
<li>将可变或可扩展部分规划为扩展点</li>
<li>抽象扩展点行为，定义接口</li>
<li>利用插件进行扩展<br><img src="https://s2.loli.net/2022/08/26/yscM5kPUYnfQIxG.png" alt="image.png"></li>
</ul>
<p><strong>Example</strong><br><img src="https://s2.loli.net/2022/08/26/9dkca5jZilVzxKJ.png" alt="image.png"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://note.youdao.com/s/YHYjgRiq">模拟源码</a></p>
</blockquote>
<h2 id="chang-yong-ren-wu-x2f-gong-ju"><span id="chang-yong-ren-wu-x2f-gong-ju">常用任务&#x2F;工具</span><a href="#chang-yong-ren-wu-x2f-gong-ju" class="header-anchor">#</a></h2><h3 id="json-jie-xi"><span id="json-jie-xi"><code>JSON</code>解析</span><a href="#json-jie-xi" class="header-anchor">#</a></h3><h4 id="nei-zhi-json-jie-xi"><span id="nei-zhi-json-jie-xi">内置<code>JSON</code>解析</span><a href="#nei-zhi-json-jie-xi" class="header-anchor">#</a></h4><blockquote>
<p>利用反射实现，通过<code>FieldTag</code>来表示对应的<code>json</code>值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">type BasicInfo struct &#123;</span><br><span class="line">	Name string `json:&quot;name&quot;`</span><br><span class="line">	Age  int    `jsom:&quot;age&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type JobInfo struct &#123;</span><br><span class="line">	Skills []string `json:&quot;skills&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Employee struct &#123;</span><br><span class="line">	BasicInfo BasicInfo `json:&quot;basic_info&quot;`</span><br><span class="line">	JobInfo   JobInfo   `json:&quot;job_info&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var jsonStr = `</span><br><span class="line">	&#123;</span><br><span class="line">	&quot;basic_info&quot;: &#123;</span><br><span class="line">	&quot;name&quot;: &quot;Mike&quot;,</span><br><span class="line">	&quot;age&quot;: 30</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;job_info&quot;: &#123;</span><br><span class="line">		&quot;skills&quot;: [&quot;Java&quot;, &quot;Go&quot;, &quot;C&quot;]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br><span class="line"></span><br><span class="line">func TestEmbeddedJson(t *testing.T) &#123;</span><br><span class="line">	e := new(Employee)</span><br><span class="line">	err := json.Unmarshal([]byte(jsonStr), e)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		t.Error(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(*e)</span><br><span class="line">	if v, err := json.Marshal(e); err != nil &#123;</span><br><span class="line">		t.Error(err)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		fmt.Println(string(v))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="easyjson"><span id="easyjson"><code>EasyJSON</code></span><a href="#easyjson" class="header-anchor">#</a></h3><blockquote>
<p><code>EasyJSON</code>采用代码生成而非反射</p>
</blockquote>
<p><strong>安装</strong><br><code>go get -u github.com/mailru/easyjson/...</code></p>
<p><strong>使用</strong><br><code>easyjson -all &lt;结构定义&gt;.go</code></p>
<blockquote>
<p>参考源码：<a target="_blank" rel="noopener" href="https://note.youdao.com/s/RrFLzfgY">https://note.youdao.com/s/RrFLzfgY</a></p>
</blockquote>
<h3 id="http-fu-wu"><span id="http-fu-wu"><code>HTTP</code>服务</span><a href="#http-fu-wu" class="header-anchor">#</a></h3><h3 id="lu-you-gui-ze"><span id="lu-you-gui-ze">路由规则</span><a href="#lu-you-gui-ze" class="header-anchor">#</a></h3><ul>
<li><code>URL</code>分为两种，末尾是<code>/</code>: 表示一个子树，后面可以跟其他子路径；末尾不是<code>/</code>，表示一个叶子，固定的路径<blockquote>
<p>以<code>/</code>结尾的<code>URL</code>可以匹配它的任何子路径，比如<code>/images</code>会匹配<code>/images/cute-cat.jpg</code></p>
</blockquote>
</li>
<li>它采用最长匹配机制，如果有多个匹配，一定采用匹配路径最长的那个进行处理</li>
<li>如果没有找到任何匹配项，会返回<code>404</code>错误</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">		fmt.Fprintf(w, &quot;Hello world!&quot;)</span><br><span class="line">	&#125;)</span><br><span class="line">	http.HandleFunc(&quot;/time/&quot;, func(writer http.ResponseWriter, request *http.Request) &#123;</span><br><span class="line">		t := time.Now()</span><br><span class="line">		timeStr := fmt.Sprintf(&quot;&#123;\&quot;time\&quot;: \&quot;%s\&quot;&#125;&quot;, t)</span><br><span class="line">		writer.Write([]byte(timeStr))</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	http.ListenAndServe(&quot;:8080&quot;, nil)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="gou-jian-restful-fu-wu"><span id="gou-jian-restful-fu-wu">构建<code>RESTful</code>服务</span><a href="#gou-jian-restful-fu-wu" class="header-anchor">#</a></h3><h4 id="geng-hao-de-router"><span id="geng-hao-de-router">更好的<code>Router</code></span><a href="#geng-hao-de-router" class="header-anchor">#</a></h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/julienschmidt/httprouter">https://github.com/julienschmidt/httprouter</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;github.com/julienschmidt/httprouter&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Index(w http.ResponseWriter, r *http.Request, _ httprouter.Params) &#123;</span><br><span class="line">	fmt.Fprintf(w, &quot;Welcome!\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Hello(w http.ResponseWriter, r *http.Request, ps httprouter.Params) &#123;</span><br><span class="line">	fmt.Fprintf(w, &quot;hello, %s!\n&quot;, ps.ByName(&quot;name&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	router := httprouter.New()</span><br><span class="line">	router.GET(&quot;/&quot;, Index)</span><br><span class="line">	router.GET(&quot;/hello/:name&quot;, Hello)</span><br><span class="line"></span><br><span class="line">	log.Fatal(http.ListenAndServe(&quot;:8080&quot;, router))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="mian-xiang-zi-yuan-de-jia-gou-resource-oriented-architecture"><span id="mian-xiang-zi-yuan-de-jia-gou-resource-oriented-architecture">面向资源的架构（Resource Oriented Architecture）</span><a href="#mian-xiang-zi-yuan-de-jia-gou-resource-oriented-architecture" class="header-anchor">#</a></h4><blockquote>
<p>在软件工程中，面向资源的架构（ROA）是一种软件架构风格和编程范式，用于支持设计和开发具有 “RESTful “接口的资源互联网形式的软件。这些资源是软件组件（离散的代码和&#x2F;或数据结构），可以为不同的目的重复使用。ROA的设计原则和指导方针在软件开发和系统集成阶段被使用。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">	&quot;encoding/json&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;github.com/julienschmidt/httprouter&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Employee struct &#123;</span><br><span class="line">	ID   string `json:&quot;id&quot;`</span><br><span class="line">	Name string `json:&quot;name&quot;`</span><br><span class="line">	Age  int    `json:&quot;age&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var employeeDB map[string]*Employee</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">	employeeDB = map[string]*Employee&#123;&#125;</span><br><span class="line">	employeeDB[&quot;Mike&quot;] = &amp;Employee&#123;&quot;e-1&quot;, &quot;Mike&quot;, 35&#125;</span><br><span class="line">	employeeDB[&quot;Rose&quot;] = &amp;Employee&#123;&quot;e-1&quot;, &quot;Rose&quot;, 45&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Index(w http.ResponseWriter, r *http.Request, _ httprouter.Params) &#123;</span><br><span class="line">	fmt.Fprintf(w, &quot;Welcome!\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func GetEmployeeByName(w http.ResponseWriter, r *http.Request, ps httprouter.Params) &#123;</span><br><span class="line">	qName := ps.ByName(&quot;name&quot;)</span><br><span class="line">	var (</span><br><span class="line">		ok       bool</span><br><span class="line">		info     *Employee</span><br><span class="line">		infoJson []byte</span><br><span class="line">		err      error</span><br><span class="line">	)</span><br><span class="line">	if info, ok = employeeDB[qName]; !ok &#123;</span><br><span class="line">		w.Write([]byte(&quot;&#123;\&quot;error\&quot;: \&quot;Not Found\&quot;&#125;&quot;))</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	if infoJson, err = json.Marshal(info); err != nil &#123;</span><br><span class="line">		w.Write([]byte(fmt.Sprintf(&quot;&#123;\&quot;error\&quot;: \&quot;%s\&quot;&#125;&quot;, err)))</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	w.Write(infoJson)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	router := httprouter.New()</span><br><span class="line">	router.GET(&quot;/&quot;, Index)</span><br><span class="line">	router.GET(&quot;/employee/:name&quot;, GetEmployeeByName)</span><br><span class="line">	fmt.Println(&quot;http://127.0.0.1:8080&quot;)</span><br><span class="line">	log.Fatal(http.ListenAndServe(&quot;:8080&quot;, router))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="xing-neng-fen-xi-yu-xing-neng-diao-you"><span id="xing-neng-fen-xi-yu-xing-neng-diao-you">性能分析与性能调优</span><a href="#xing-neng-fen-xi-yu-xing-neng-diao-you" class="header-anchor">#</a></h2><h3 id="pprof-zhi-nan"><span id="pprof-zhi-nan"><code>pprof</code>指南</span><a href="#pprof-zhi-nan" class="header-anchor">#</a></h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/396363069">https://zhuanlan.zhihu.com/p/396363069</a></p>
</blockquote>
<h3 id="xing-neng-fen-xi-gong-ju"><span id="xing-neng-fen-xi-gong-ju">性能分析工具</span><a href="#xing-neng-fen-xi-gong-ju" class="header-anchor">#</a></h3><ul>
<li>安装<code>graphviz</code></li>
<li>将<code>$GOPATH/bin</code>加入<code>$PATH</code></li>
<li>安装<code>go-torch</code></li>
<li><ul>
<li><code>go get github.com/uber/go-torch</code></li>
</ul>
</li>
<li><ul>
<li>下载并复制<code>flamegraph.pl</code>(<a target="_blank" rel="noopener" href="https://github.com/brendangregg/FlameGraph)%E8%87%B3%60$PATH/bin%60%E8%B7%AF%E5%BE%84%E4%B8%8B">https://github.com/brendangregg/FlameGraph)至`$PATH/bin`路径下</a></li>
</ul>
</li>
<li><ul>
<li>将<code>$GOPATH/bin</code>加入<code>$PATH</code></li>
</ul>
</li>
<li></li>
</ul>
<h4 id="tong-guo-wen-jian-fang-shi-shu-chu-profile"><span id="tong-guo-wen-jian-fang-shi-shu-chu-profile">通过文件方式输出<code>Profile</code></span><a href="#tong-guo-wen-jian-fang-shi-shu-chu-profile" class="header-anchor">#</a></h4><ul>
<li>灵活性高，适用于特定代码段的分析</li>
<li>通过手动调用<code>runtime/pprof</code>的<code>API</code></li>
<li><code>API</code><a target="_blank" rel="noopener" href="http://docscn.studygolang.com/pkg/runtime/pprof/">相关文档</a></li>
<li><code>go tool pprof [binary] [binary.prof]</code></li>
</ul>
<h4 id="go-zhi-chi-de-duo-chong-profile"><span id="go-zhi-chi-de-duo-chong-profile">Go支持的多种<code>Profile</code></span><a href="#go-zhi-chi-de-duo-chong-profile" class="header-anchor">#</a></h4><ul>
<li><code>go help testflag</code></li>
<li><a target="_blank" rel="noopener" href="https://golang.org/src/runtime/pprof/pprof.go">https://golang.org/src/runtime/pprof/pprof.go</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;math/rand&quot;</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">	&quot;runtime/pprof&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	col = 10000</span><br><span class="line">	row = 10000</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func fillMatrix(m *[row][col]int) &#123;</span><br><span class="line">	r := rand.New(rand.NewSource(time.Now().UnixNano()))</span><br><span class="line"></span><br><span class="line">	for i := 0; i &lt; row; i++ &#123;</span><br><span class="line">		for j := 0; j &lt; col; j++ &#123;</span><br><span class="line">			m[i][j] = r.Intn(100000)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func calculate(m *[row][col]int) &#123;</span><br><span class="line">	for i := 0; i &lt; row; i++ &#123;</span><br><span class="line">		tmp := 0</span><br><span class="line">		for j := 0; j &lt; col; j++ &#123;</span><br><span class="line">			tmp += m[i][j]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	// 创建输出文件</span><br><span class="line">	f, err := os.Create(&quot;cpu.prof&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatal(&quot;could not create CPU profile: &quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if err := pprof.StartCPUProfile(f); err != nil &#123; // 监控CPU</span><br><span class="line">		log.Fatal(&quot;could not start CPU profile: &quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	defer pprof.StopCPUProfile()</span><br><span class="line"></span><br><span class="line">	// 主逻辑区，进行一些简单的代码运算</span><br><span class="line">	x := [row][col]int&#123;&#125;</span><br><span class="line">	fillMatrix(&amp;x)</span><br><span class="line">	calculate(&amp;x)</span><br><span class="line"></span><br><span class="line">	f1, err := os.Create(&quot;mem.prof&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatal(&quot;could not create memory profile: &quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	//runtime.GC()                                       // GC, 获取最新的数据信息</span><br><span class="line">	if err := pprof.WriteHeapProfile(f1); err != nil &#123; // 写入内存消息</span><br><span class="line">		log.Fatal(&quot;could not write memory profile: &quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	f1.Close()</span><br><span class="line"></span><br><span class="line">	f2, err := os.Create(&quot;goroutine.prof&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatal(&quot;could not create groutine profile: &quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if gProf := pprof.Lookup(&quot;goroutine&quot;); gProf != nil &#123;</span><br><span class="line">		gProf.WriteTo(f2, 0)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		log.Fatal(&quot;could not write groutine profile: &quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	f2.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>生成<code>.prof</code>文件</strong><br><code>go build prof.go</code></p>
<p><strong>测试它</strong><br><code>go tool pprof [prof|pprof.exe] *.prof</code></p>
<h4 id="tong-guo-http-fang-shi-shu-chu-profile"><span id="tong-guo-http-fang-shi-shu-chu-profile">通过<code>HTTP</code>方式输出<code>Profile</code></span><a href="#tong-guo-http-fang-shi-shu-chu-profile" class="header-anchor">#</a></h4><ul>
<li>简单，适合于持续性运行的应用</li>
<li>在应用程序中导入<code>import _ &quot;net/http/pprof&quot;</code>, 并启动<code>http server</code>即可</li>
<li><code>http://&lt;host&gt;:&lt;posrt&gt;/debug/pprof/</code></li>
<li><code>go tool pprof _http://&lt;host&gt;:&lt;port&gt;/debug/pprof/profile?seconds=10</code>（默认值为30秒）</li>
<li><code>go-tourch -seconds 10 http://&lt;host&gt;:&lt;port&gt;/debug/pprof/profile</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">	_ &quot;net/http/pprof&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func GetFibonacciSerie(n int) []int &#123;</span><br><span class="line">	ret := make([]int, 2, n)</span><br><span class="line">	ret[0] = 1</span><br><span class="line">	ret[1] = 1</span><br><span class="line">	for i := 2; i &lt; n; i++ &#123;</span><br><span class="line">		ret = append(ret, ret[i-2]+ret[i-1])</span><br><span class="line">	&#125;</span><br><span class="line">	return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func index(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	w.Write([]byte(&quot;welcome!&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createFBS(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	var fbs []int</span><br><span class="line">	for i := 0; i &lt; 1000000; i++ &#123;</span><br><span class="line">		fbs = GetFibonacciSerie(50)</span><br><span class="line">	&#125;</span><br><span class="line">	w.Write([]byte(fmt.Sprintf(&quot;%v&quot;, fbs)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	http.HandleFunc(&quot;/&quot;, index)</span><br><span class="line">	http.HandleFunc(&quot;/fb&quot;, createFBS)</span><br><span class="line">	log.Fatal(http.ListenAndServe(&quot;:8081&quot;, nil))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>然后</strong><br><code>go tool pprof -http=&quot;:8082&quot; http://192.168.0.103:8081/debug/pprof/profile?seconds=10</code></p>
<h3 id="xing-neng-diao-you"><span id="xing-neng-diao-you">性能调优</span><a href="#xing-neng-diao-you" class="header-anchor">#</a></h3><p><img src="https://s2.loli.net/2022/08/26/jLEcvn6XsqBktFz.png" alt="image.png"></p>
<h4 id="chang-jian-fen-xi-zhi-biao"><span id="chang-jian-fen-xi-zhi-biao">常见分析指标</span><a href="#chang-jian-fen-xi-zhi-biao" class="header-anchor">#</a></h4><ul>
<li><code>Wall Time</code>: 测量的是过去了多少时间</li>
<li><code>CPU Time</code><blockquote>
<p>CPU时间是使用中央处理单元处理计算机程序或操作系统的指令的时间量，与经过的时间相对应，包括等待输入&#x2F;输出操作或进入低功耗模式的时间。</p>
</blockquote>
</li>
<li><code>Block Time</code>: 运行阻塞的时间</li>
<li><code>Memory allocation</code>: 动态内存分配又称为堆内存分配，是指计算机程序在运行期中分配使用内存</li>
<li><code>GC times/time spent</code>: 自上次GC结束后在GC中花费的时间<blockquote>
<p>自上次GC结束后在GC中花费的时间的百分比。例如，从上一次GC结束到现在已经有100万个周期，我们在当前的GC中花费了30万个周期，这个计数器将显示30%。</p>
</blockquote>
</li>
</ul>
<p><strong><code>Go bench</code>生成prof</strong></p>
<blockquote>
<p><code>go test -bench=. -cpuprofile=cpu.prof</code><br><code>go test -bench=. -memprofile=cem.prof</code></p>
</blockquote>
<h6 id="example"><span id="example">Example</span><a href="#example" class="header-anchor">#</a></h6><p><strong><code>structs.go</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package memOperation</span><br><span class="line"></span><br><span class="line">type Request struct &#123;</span><br><span class="line">	TransactionID string `json:&quot;transaction_id&quot;`</span><br><span class="line">	Payload       []int  `json:&quot;payload&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Response struct &#123;</span><br><span class="line">	TransactionID string `json:&quot;transaction_id&quot;`</span><br><span class="line">	Expression    string `json:&quot;expression&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><code>optimization.go</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package memOperation</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;encoding/json&quot;</span><br><span class="line">	&quot;strconv&quot;</span><br><span class="line">	&quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func createRequest() string &#123;</span><br><span class="line">	payload := make([]int, 100, 100)</span><br><span class="line">	for i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">		payload[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">	req := Request&#123;&quot;demo_transaction&quot;, payload&#125;</span><br><span class="line">	v, err := json.Marshal(&amp;req)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	return string(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func processRequestOld(reqs []string) []string &#123;</span><br><span class="line">	reps := []string&#123;&#125;</span><br><span class="line">	for _, req := range reqs &#123;</span><br><span class="line">		reqObj := &amp;Request&#123;&#125;</span><br><span class="line">		json.Unmarshal([]byte(req), reqObj)</span><br><span class="line">		ret := &quot;&quot;</span><br><span class="line">		for _, e := range reqObj.Payload &#123;</span><br><span class="line">			ret += strconv.Itoa(e) + &quot;,&quot;</span><br><span class="line">		&#125;</span><br><span class="line">		repObj := &amp;Response&#123;reqObj.TransactionID, ret&#125;</span><br><span class="line">		repJson, err := json.Marshal(&amp;repObj)</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			panic(err)</span><br><span class="line">		&#125;</span><br><span class="line">		reps = append(reps, string(repJson))</span><br><span class="line">	&#125;</span><br><span class="line">	return reps</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func processRequest(reqs []string) []string &#123;</span><br><span class="line">	reps := []string&#123;&#125;</span><br><span class="line">	for _, req := range reqs &#123;</span><br><span class="line">		reqObj := &amp;Request&#123;&#125;</span><br><span class="line">		reqObj.UnmarshalJSON([]byte(req))</span><br><span class="line">		//json.Unmarshal([]byte(req), reqObj)</span><br><span class="line">		ret := &quot;&quot;</span><br><span class="line">		var buf strings.Builder</span><br><span class="line">		for _, e := range reqObj.Payload &#123;</span><br><span class="line">			buf.WriteString(strconv.Itoa(e))</span><br><span class="line">			buf.WriteString(&quot;,&quot;)</span><br><span class="line">			//ret += strconv.Itoa(e) + &quot;,&quot;</span><br><span class="line">		&#125;</span><br><span class="line">		repObj := &amp;Response&#123;reqObj.TransactionID, ret&#125;</span><br><span class="line">		repJson, err := repObj.MarshalJSON()</span><br><span class="line">		//repJson, err := json.Marshal(&amp;repObj)</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			panic(err)</span><br><span class="line">		&#125;</span><br><span class="line">		reps = append(reps, string(repJson))</span><br><span class="line">	&#125;</span><br><span class="line">	return reps</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><code>optimization_test.go</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package memOperation</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">func TestCreateRequest(t *testing.T) &#123;</span><br><span class="line">	str := createRequest()</span><br><span class="line">	t.Log(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestProcessRequest(t *testing.T) &#123;</span><br><span class="line">	reqs := []string&#123;&#125;</span><br><span class="line">	reqs = append(reqs, createRequest())</span><br><span class="line">	reps := processRequest(reqs)</span><br><span class="line">	t.Log(reps[0])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkProcessRequest(b *testing.B) &#123;</span><br><span class="line">	reqs := []string&#123;&#125;</span><br><span class="line">	reqs = append(reqs, createRequest())</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = processRequest(reqs)</span><br><span class="line">	&#125;</span><br><span class="line">	b.StopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkProcessRequestOld(b *testing.B) &#123;</span><br><span class="line">	reqs := []string&#123;&#125;</span><br><span class="line">	reqs = append(reqs, createRequest())</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = processRequestOld(reqs)</span><br><span class="line">	&#125;</span><br><span class="line">	b.StopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>使用<code>easyjson</code>优化<code>Json</code>解析的问题</strong><br><code>easyjson.exe -all structs.go</code></p>
<h3 id="xing-neng-bu-neng-bei-suo-zhu"><span id="xing-neng-bu-neng-bei-suo-zhu">性能不能被锁住</span><a href="#xing-neng-bu-neng-bei-suo-zhu" class="header-anchor">#</a></h3><h4 id="suo-dui-xing-neng-de-ying-xiang-bi-jiao-da"><span id="suo-dui-xing-neng-de-ying-xiang-bi-jiao-da">锁对性能的影响比较大</span><a href="#suo-dui-xing-neng-de-ying-xiang-bi-jiao-da" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package notBeLock</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var cache map[string]string</span><br><span class="line"></span><br><span class="line">const NUM_OF_READER int = 40</span><br><span class="line">const READ_TIMES int = 100000</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">	cache = make(map[string]string)</span><br><span class="line"></span><br><span class="line">	cache[&quot;a&quot;] = &quot;aa&quot;</span><br><span class="line">	cache[&quot;b&quot;] = &quot;bb&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func lockFreeAccess() &#123;</span><br><span class="line"></span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	wg.Add(NUM_OF_READER)</span><br><span class="line">	for i := 0; i &lt; NUM_OF_READER; i++ &#123;</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for j := 0; j &lt; READ_TIMES; j++ &#123;</span><br><span class="line">				_, err := cache[&quot;a&quot;]</span><br><span class="line">				if !err &#123;</span><br><span class="line">					fmt.Println(&quot;Noting&quot;)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func lockAccess() &#123;</span><br><span class="line"></span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	wg.Add(NUM_OF_READER)</span><br><span class="line">	m := new(sync.RWMutex)</span><br><span class="line">	for i := 0; i &lt; NUM_OF_READER; i++ &#123;</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for j := 0; j &lt; READ_TIMES; j++ &#123;</span><br><span class="line">				m.RLock()</span><br><span class="line">				_, err := cache[&quot;a&quot;]</span><br><span class="line">				if !err &#123;</span><br><span class="line">					fmt.Println(&quot;Noting&quot;)</span><br><span class="line">				&#125;</span><br><span class="line">				m.RUnlock()</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkLockFree(b *testing.B) &#123;</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">		lockFreeAccess()</span><br><span class="line">	&#125;</span><br><span class="line">	b.StopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkLock(b *testing.B) &#123;</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">		lockAccess()</span><br><span class="line">	&#125;</span><br><span class="line">	b.StopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="sync-map-yuan-map-bu-zhi-chi-xian-cheng-an-quan"><span id="sync-map-yuan-map-bu-zhi-chi-xian-cheng-an-quan"><code>sync.Map</code>,原<code>Map</code>不支持线程安全</span><a href="#sync-map-yuan-map-bu-zhi-chi-xian-cheng-an-quan" class="header-anchor">#</a></h4><ul>
<li><code>sync.Map</code>适合读多写少，且<code>Key</code>相对稳定的环境</li>
<li><code>sync.Map</code>采用了空间换时间的方案，并且采用指针的方式间接实现值得映射，所以存储空间会较<code>built-in map</code>大<br><img src="https://s2.loli.net/2022/08/26/HPRDpYjmoNaQleB.png" alt="image.png"><blockquote>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/qiangmzsx/blog/1827059">https://my.oschina.net/qiangmzsx/blog/1827059</a></p>
</blockquote>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/08/26/Mw3Lr8kclxmzjOi.png" alt="image.png"></p>
<h4 id="xing-neng-suo-xiao-jie"><span id="xing-neng-suo-xiao-jie">性能锁小结</span><a href="#xing-neng-suo-xiao-jie" class="header-anchor">#</a></h4><ul>
<li>减少锁的影响范围</li>
<li>减少发生锁冲突的概率</li>
<li><ul>
<li><code>sync.Map</code></li>
</ul>
</li>
<li><ul>
<li><code>ConcurrentMap</code></li>
</ul>
</li>
<li>避免锁的使用</li>
<li><ul>
<li><code>LAMX Disruptor</code>：<a target="_blank" rel="noopener" href="https://martinfowler.com/articles/lmax.html">https://martinfowler.com/articles/lmax.html</a></li>
</ul>
</li>
</ul>
<h4 id="example"><span id="example"><code>Example</code></span><a href="#example" class="header-anchor">#</a></h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://note.youdao.com/s/5KLTdMdd">https://note.youdao.com/s/5KLTdMdd</a></p>
</blockquote>
<h3 id="gc-you-hao-dai-ma"><span id="gc-you-hao-dai-ma"><code>GC</code>友好代码</span><a href="#gc-you-hao-dai-ma" class="header-anchor">#</a></h3><h4 id="bi-mian-nei-cun-fen-pei-he-fu-zhi"><span id="bi-mian-nei-cun-fen-pei-he-fu-zhi">避免内存分配和复制</span><a href="#bi-mian-nei-cun-fen-pei-he-fu-zhi" class="header-anchor">#</a></h4><ul>
<li>复杂对象尽量传递引用</li>
<li><ul>
<li>数组得传递</li>
</ul>
</li>
<li><ul>
<li>结构体传递</li>
</ul>
</li>
</ul>
<h4 id="da-kai-gc-ri-zhi"><span id="da-kai-gc-ri-zhi">打开<code>GC</code>日志</span><a href="#da-kai-gc-ri-zhi" class="header-anchor">#</a></h4><p>只要在程序之前加上环境变量<code>GODEBUG=gctrace=1</code>,<br>如：<code>GODEBUG=gctrace=1 go test -bench=.</code><br><code>GODEBUG=gctrace=1 go run main.go</code><br><img src="https://s2.loli.net/2022/08/26/WMuCH9OyDv5bhLN.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package passing_ref</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const NumOfElems = 1000</span><br><span class="line"></span><br><span class="line">type Content struct &#123;</span><br><span class="line">	Detail [10000]int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func withValue(arr [NumOfElems]Content) int &#123;</span><br><span class="line">	//fmt.Println(&amp;arr[2])</span><br><span class="line">	return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func withReference(arr *[NumOfElems]Content) int &#123;</span><br><span class="line">	//b := *arr</span><br><span class="line">	//for i, content := range b &#123;</span><br><span class="line">	//	fmt.Println(i)</span><br><span class="line">	//	fmt.Println(content)</span><br><span class="line">	//&#125;</span><br><span class="line">	//fmt.Println(&amp;arr[2])</span><br><span class="line">	return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestIn(t *testing.T) &#123;</span><br><span class="line">	var arr [NumOfElems]Content</span><br><span class="line">	withValue(arr)</span><br><span class="line">	withReference(&amp;arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkPassingArrayWithValue(b *testing.B) &#123;</span><br><span class="line">	var arr [NumOfElems]Content</span><br><span class="line"></span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">		withValue(arr)</span><br><span class="line">	&#125;</span><br><span class="line">	b.StopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkPassingArrayWithRef(b *testing.B) &#123;</span><br><span class="line">	var arr [NumOfElems]Content</span><br><span class="line"></span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">		withReference(&amp;arr)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="go-tool-trace"><span id="go-tool-trace"><code>go tool trace</code></span><a href="#go-tool-trace" class="header-anchor">#</a></h4><h5 id="pu-tong-cheng-xu-shu-chu"><span id="pu-tong-cheng-xu-shu-chu">普通程序输出</span><a href="#pu-tong-cheng-xu-shu-chu" class="header-anchor">#</a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">	&quot;runtime/trace&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	f, err := os.Create(&quot;trace.out&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	defer f.Close()</span><br><span class="line"></span><br><span class="line">	err = trace.Start(f)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	defer trace.Stop()</span><br><span class="line">	// Your program here</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="ce-shi-cheng-xu-shu-chu-trace-xin-xi"><span id="ce-shi-cheng-xu-shu-chu-trace-xin-xi">测试程序输出<code>trace</code>信息</span><a href="#ce-shi-cheng-xu-shu-chu-trace-xin-xi" class="header-anchor">#</a></h5><p><code>go test -trace trace.out</code></p>
<h5 id="ke-shi-hua-trace-xin-xi"><span id="ke-shi-hua-trace-xin-xi">可视化<code>trace</code>信息</span><a href="#ke-shi-hua-trace-xin-xi" class="header-anchor">#</a></h5><p><code>go tool trace trace.out</code></p>
<h4 id="bi-mian-nei-cun-fen-pei-he-fu-zhi"><span id="bi-mian-nei-cun-fen-pei-he-fu-zhi">避免内存分配和复制</span><a href="#bi-mian-nei-cun-fen-pei-he-fu-zhi" class="header-anchor">#</a></h4><ul>
<li>初始化至合适的大小</li>
<li><ul>
<li>自动扩容室友代价的</li>
</ul>
</li>
<li>复用内存</li>
</ul>
<h3 id="gao-xiao-zi-fu-chuan-lian-jie"><span id="gao-xiao-zi-fu-chuan-lian-jie">高效字符串连接</span><a href="#gao-xiao-zi-fu-chuan-lian-jie" class="header-anchor">#</a></h3><blockquote>
<p>推荐使用<code>strings.Builder</code>(Go 1.10后版本)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package concatString</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;bytes&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;strconv&quot;</span><br><span class="line">	&quot;strings&quot;</span><br><span class="line">	&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const numbers = 100</span><br><span class="line"></span><br><span class="line">func BenchmarkSprintf(b *testing.B) &#123;</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for idx := 0; idx &lt; b.N; idx++ &#123;</span><br><span class="line">		var s string</span><br><span class="line">		for i := 0; i &lt; numbers; i++ &#123;</span><br><span class="line">			s = fmt.Sprintf(&quot;%v%v&quot;, s, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	b.StopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkStringBuilder(b *testing.B) &#123;</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for idx := 0; idx &lt; b.N; idx++ &#123;</span><br><span class="line">		var builder strings.Builder</span><br><span class="line">		for i := 0; i &lt; numbers; i++ &#123;</span><br><span class="line">			builder.WriteString(strconv.Itoa(i))</span><br><span class="line">		&#125;</span><br><span class="line">		_ = builder.String()</span><br><span class="line">	&#125;</span><br><span class="line">	b.StopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkBytesBuf(b *testing.B) &#123;</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for idx := 0; idx &lt; b.N; idx++ &#123;</span><br><span class="line">		var buf bytes.Buffer</span><br><span class="line">		for i := 0; i &lt; numbers; i++ &#123;</span><br><span class="line">			buf.WriteString(strconv.Itoa(i))</span><br><span class="line">		&#125;</span><br><span class="line">		_ = buf.String()</span><br><span class="line">	&#125;</span><br><span class="line">	b.StopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkStringAdd(b *testing.B) &#123;</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for idx := 0; idx &lt; b.N; idx++ &#123;</span><br><span class="line">		var s string</span><br><span class="line">		for i := 0; i &lt; numbers; i++ &#123;</span><br><span class="line">			s += strconv.Itoa(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	b.StopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: stringOperatation/concatString</span><br><span class="line">cpu: AMD Ryzen 7 3700X 8-Core Processor</span><br><span class="line">BenchmarkSprintf</span><br><span class="line">BenchmarkSprintf-16                72243             16357 ns/op</span><br><span class="line">BenchmarkStringBuilder</span><br><span class="line">BenchmarkStringBuilder-16        1815912               660.3 ns/op</span><br><span class="line">BenchmarkBytesBuf</span><br><span class="line">BenchmarkBytesBuf-16             1448607               832.6 ns/op</span><br><span class="line">BenchmarkStringAdd</span><br><span class="line">BenchmarkStringAdd-16             249799              4913 ns/op</span><br><span class="line">PASS</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="fen-bu-shi-xi-tong-jia-gou-gao-ke-yong"><span id="fen-bu-shi-xi-tong-jia-gou-gao-ke-yong">分布式系统架构（高可用）</span><a href="#fen-bu-shi-xi-tong-jia-gou-gao-ke-yong" class="header-anchor">#</a></h2><h3 id="mian-xiang-cuo-wu-she-ji"><span id="mian-xiang-cuo-wu-she-ji">面向错误设计</span><a href="#mian-xiang-cuo-wu-she-ji" class="header-anchor">#</a></h3><p><img src="https://s2.loli.net/2022/08/26/xuOfeWDlb9jNsIh.png" alt="image.png"></p>
<h4 id="ge-chi"><span id="ge-chi">隔离</span><a href="#ge-chi" class="header-anchor">#</a></h4><blockquote>
<p>当系统一部分发生错误时候，尽量减少它对其他部分的影响，让系统能按一定功能继续工作，可以被用户所使用</p>
</blockquote>
<h5 id="wei-nei-he"><span id="wei-nei-he"><strong>微内核</strong></span><a href="#wei-nei-he" class="header-anchor">#</a></h5><p><img src="https://s2.loli.net/2022/08/26/sQBTWFekr9hfvIy.png" alt="image.png"></p>
<h5 id="wei-fu-wu"><span id="wei-fu-wu"><strong>微服务</strong></span><a href="#wei-fu-wu" class="header-anchor">#</a></h5><p><img src="https://s2.loli.net/2022/08/26/Lp6otsB1eU5Gzlc.png" alt="image.png"></p>
<h5 id="chong-yong-vs-ge-chi"><span id="chong-yong-vs-ge-chi">重用 vs 隔离</span><a href="#chong-yong-vs-ge-chi" class="header-anchor">#</a></h5><p><img src="https://s2.loli.net/2022/08/26/EzT7GXDMdP6fjSH.png" alt="image.png"></p>
<h4 id="rong-yu"><span id="rong-yu">冗余</span><a href="#rong-yu" class="header-anchor">#</a></h4><p><img src="https://s2.loli.net/2022/08/26/bHQe3PN9Zz6Xh2f.png" alt="image.png"></p>
<h4 id="dan-dian-shi-xiao"><span id="dan-dian-shi-xiao">单点失效</span><a href="#dan-dian-shi-xiao" class="header-anchor">#</a></h4><p><img src="https://s2.loli.net/2022/08/26/u2XUxhoiqfHTAtj.png" alt="image.png"></p>
<h4 id="jie-jue-dan-dian-shi-xiao-xian-liu"><span id="jie-jue-dan-dian-shi-xiao-xian-liu">解决<code>单点失效</code>—— 限流</span><a href="#jie-jue-dan-dian-shi-xiao-xian-liu" class="header-anchor">#</a></h4><blockquote>
<p>扛不住就只能增加服务器了</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/08/26/n1CA7ZvtoRhrkmW.png" alt="image.png"></p>
<h4 id="man-xiang-ying"><span id="man-xiang-ying">慢响应</span><a href="#man-xiang-ying" class="header-anchor">#</a></h4><p><img src="https://s2.loli.net/2022/08/26/F4WxflBVYq32PLm.png" alt="image.png"></p>
<h4 id="bu-yao-wu-xiu-zhi-de-deng-dai"><span id="bu-yao-wu-xiu-zhi-de-deng-dai">不要无休止的等待</span><a href="#bu-yao-wu-xiu-zhi-de-deng-dai" class="header-anchor">#</a></h4><p><img src="https://s2.loli.net/2022/08/26/DTqHK4YIsrwxUPQ.png" alt="image.png"></p>
<h4 id="cuo-wu-chuan-di"><span id="cuo-wu-chuan-di">错误传递</span><a href="#cuo-wu-chuan-di" class="header-anchor">#</a></h4><p><img src="https://s2.loli.net/2022/08/26/jVSzhwFTvrDxfXH.png" alt="image.png"></p>
<h4 id="duan-lu-qi"><span id="duan-lu-qi">断路器</span><a href="#duan-lu-qi" class="header-anchor">#</a></h4><p><img src="https://s2.loli.net/2022/08/26/zdUpw6ibICj7m9f.png" alt="image.png"></p>
<h3 id="mian-xiang-hui-fu-she-ji"><span id="mian-xiang-hui-fu-she-ji">面向恢复设计</span><a href="#mian-xiang-hui-fu-she-ji" class="header-anchor">#</a></h3><p><img src="https://s2.loli.net/2022/08/26/uU7KQlRtsO9cbT5.png" alt="image.png"></p>
<h4 id="jian-kang-jian-cha"><span id="jian-kang-jian-cha">健康检查</span><a href="#jian-kang-jian-cha" class="header-anchor">#</a></h4><ul>
<li>注意僵尸进程</li>
<li><ul>
<li>池化资源耗尽</li>
</ul>
</li>
<li><ul>
<li>死锁</li>
</ul>
</li>
</ul>
<h4 id="let-it-crash"><span id="let-it-crash"><code>Let it Crash</code></span><a href="#let-it-crash" class="header-anchor">#</a></h4><p><img src="https://s2.loli.net/2022/08/26/BO3rPySNcxIqzMZ.png" alt="image.png"></p>
<h4 id="gou-jian-ke-hui-fu-de-xi-tong"><span id="gou-jian-ke-hui-fu-de-xi-tong">构建可恢复的系统</span><a href="#gou-jian-ke-hui-fu-de-xi-tong" class="header-anchor">#</a></h4><ul>
<li>拒绝单体系统</li>
<li>面向错误和恢复的设计</li>
<li><ul>
<li>在依赖服务不可用时，可以继续存活</li>
</ul>
</li>
<li><ul>
<li>快速启动</li>
</ul>
</li>
<li><ul>
<li>无状态</li>
</ul>
</li>
</ul>
<h4 id="yu-ke-hu-duan-xie-shang"><span id="yu-ke-hu-duan-xie-shang">与客户端协商</span><a href="#yu-ke-hu-duan-xie-shang" class="header-anchor">#</a></h4><p><img src="https://s2.loli.net/2022/08/26/WwRa9ZtXTkpSyz5.png" alt="image.png"></p>
<h3 id="chaos-engineering"><span id="chaos-engineering"><code>chaos engineering</code></span><a href="#chaos-engineering" class="header-anchor">#</a></h3><p><img src="https://s2.loli.net/2022/08/26/1TPgxAWX5pRYfFq.png" alt="image.png"></p>
<ul>
<li>如果问题经常发生人们就会学习和思考解决它的办法<br><img src="https://s2.loli.net/2022/08/26/Kxe18o52ZgnwdOF.png" alt="image.png"></li>
</ul>
<h4 id="cgaos-engineering-yuan-ze"><span id="cgaos-engineering-yuan-ze"><code>Cgaos Engineering</code>原则</span><a href="#cgaos-engineering-yuan-ze" class="header-anchor">#</a></h4><ul>
<li>Build a Hypothesis around Steady State Behavior<blockquote>
<p>围绕稳定行为建立一个假设</p>
</blockquote>
</li>
<li>Vary Real-World Events<blockquote>
<p>尝试各种各样真实世界的事件</p>
</blockquote>
</li>
<li>Run Experiments in Production<blockquote>
<p>实验运行在生产环境中</p>
</blockquote>
</li>
<li>Automate Experiments to Run Continuously<blockquote>
<p>自动化实验持续运行而不是依赖人工</p>
</blockquote>
</li>
<li>Minimize Blast Radius<blockquote>
<p>最小化毁坏范围，不能给用户带来影响</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://principlesofchaos.org/">http://principlesofchaos.org</a></p>
</blockquote>
<h4 id="xiang-guan-kai-yuan-xiang-mu"><span id="xiang-guan-kai-yuan-xiang-mu">相关开源项目</span><a href="#xiang-guan-kai-yuan-xiang-mu" class="header-anchor">#</a></h4><p><a target="_blank" rel="noopener" href="https://github.com/Netflix/chaosmonkey">https://github.com/Netflix/chaosmonkey</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/easierway/service_decorators/blob/master/README.md">https://github.com/easierway/service_decorators/blob/master/README.md</a></p>
<h2 id="tu-shu-tui-jian"><span id="tu-shu-tui-jian">图书推荐</span><a href="#tu-shu-tui-jian" class="header-anchor">#</a></h2><ul>
<li><p><input checked disabled type="checkbox"> 
《Go程序设计语言》<br><img src="https://s2.loli.net/2022/08/26/9WaYmLDs6KjB1PC.png" alt="image.png"></p>
</li>
<li><p><input disabled type="checkbox"> 
《面向模式的软件架构》<br><img src="https://s2.loli.net/2022/08/26/tlRNVWS3CvYXknD.png" alt="image.png"></p>
</li>
<li><p><input disabled type="checkbox"> 
《计算机程序的构造和解释》<br><img src="https://s2.loli.net/2022/08/26/xih3ZKOtDA4swdj.png" alt="image.png"></p>
</li>
</ul>

    </div>

<!--    <aside id="article-toc" role="navigation" class="fixed">
    <div id="article-toc-inner">
        <strong class="sidebar-title">
            目录
        </strong>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#go-yu-yan-cong-ru-men-dao-shi-zhan-bi-ji"><span class="toc-text">Go 语言从入门到实战 笔记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ji-chu-bu-fen"><span class="toc-text">基础部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#chai-yi-yu-ji-chu"><span class="toc-text">差异与基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tui-chu-fan-hui-zhi"><span class="toc-text">退出返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#huo-qu-ming-ling-xing-can-shu"><span class="toc-text">获取命令行参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bian-liang-fu-zhi"><span class="toc-text">变量赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kuai-su-she-zhi-lian-xu-zhi"><span class="toc-text">快速设置连续值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lei-xing-zhuan-hua"><span class="toc-text">类型转化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zhi-zhen-lei-xing"><span class="toc-text">指针类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#suan-zhu-yun-suan-fu"><span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yong-bi-jiao-shu-zu"><span class="toc-text">用&#x3D;&#x3D;比较数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wei-yun-suan-fu-amp-an-wei-zhi-ling"><span class="toc-text">位运算符，&amp;^按位置零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xun-huan"><span class="toc-text">循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-tiao-jian"><span class="toc-text">if条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch-tiao-jian"><span class="toc-text">switch条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#qie-pian"><span class="toc-text">切片</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#qie-pian-sheng-ming"><span class="toc-text">切片声明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#qie-pian-ru-he-shi-xian-ke-bian-chang"><span class="toc-text">切片如何实现可变长</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-sheng-ming"><span class="toc-text">Map声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#map-yuan-su-de-fang-wen"><span class="toc-text">Map元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-bian-li"><span class="toc-text">Map遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-yu-gong-han-mo-shi"><span class="toc-text">Map与工厂模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shi-xian-set"><span class="toc-text">实现Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zi-fu-chuan"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#unicode-utf8"><span class="toc-text">Unicode UTF8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string-zhuan-rune"><span class="toc-text">String转rune</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chang-yong-de-zi-fu-chuan-han-shu"><span class="toc-text">常用的字符串函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#han-shu-shi-yi-deng-gong-min"><span class="toc-text">函数是一等公民</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ke-bian-can-shu"><span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#defer-han-shu"><span class="toc-text">defer函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-de-cuo-wu-ji-zhi"><span class="toc-text">Go的错误机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#panic"><span class="toc-text">panic</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#panic-vs-os-exit"><span class="toc-text">panic VS os.Exit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bu-huo-suo-you-cuo-wu-recover"><span class="toc-text">捕获所有错误 recover</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3d-x3d-shi-yong-recover-xu-jin-shen-x3d-x3d"><span class="toc-text">&#x3D;&#x3D;使用recover需谨慎&#x3D;&#x3D;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-de-yi-lai-guan-li"><span class="toc-text">GO的依赖管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#package"><span class="toc-text">package</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#remote-package"><span class="toc-text">remote package</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#init-fang-fa"><span class="toc-text">init方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#init-han-shu-de-zhu-yao-zuo-yong"><span class="toc-text">init函数的主要作用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init-han-shu-de-zhu-yao-te-dian"><span class="toc-text">init函数的主要特点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-wei-jie-jue-de-yi-lai-wen-ti"><span class="toc-text">Go未解决的依赖问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vendor-lu-jing"><span class="toc-text">vendor路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chang-yong-de-yi-lai-guan-li-gong-ju"><span class="toc-text">常用的依赖管理工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-de-jiao-cha-bian-yi"><span class="toc-text">Go的交叉编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bing-fa-bian-cheng"><span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-vs-groutine"><span class="toc-text">Thread VS Groutine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gong-xiang-nei-cun-bing-fa-ji-zhi"><span class="toc-text">共享内存并发机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-mutex-hu-chi-suo"><span class="toc-text">sync.Mutex 互斥锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-waitgroup-tong-bu-xian-cheng-lei-si-java-zhong-de-join"><span class="toc-text">sync.WaitGroup同步线程 类似java中的join</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#csp-bing-fa-ji-zhi-go-yu-yan-te-you-de"><span class="toc-text">CSP并发机制（Go语言特有的）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#csp-vs-actor"><span class="toc-text">CSP vs Actor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#channel"><span class="toc-text">Channel</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#duo-lu-xuan-ze-he-chao-shi"><span class="toc-text">多路选择和超时</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#duo-lu-xuan-ze"><span class="toc-text">多路选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chao-shi-kong-zhi"><span class="toc-text">超时控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#channel-de-guan-bi"><span class="toc-text">channel的关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ren-wu-qu-xiao"><span class="toc-text">任务取消</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#context-yu-ren-wu-qu-xiao"><span class="toc-text">Context 与 任务取消</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#context"><span class="toc-text">Context</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zhi-yun-xing-yi-ci"><span class="toc-text">只运行一次</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dan-li-mo-shi-lan-han-shi-xian-cheng-an-quan"><span class="toc-text">单例模式 （懒汉式，线程安全）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jin-xu-ren-yi-ren-wu-wan-cheng"><span class="toc-text">仅需任意任务完成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#suo-you-ren-wu-wan-cheng"><span class="toc-text">所有任务完成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dui-xiang-chi"><span class="toc-text">对象池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sync-pool-dui-xiang-huan-cun"><span class="toc-text">sync.Pool对象缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-pool-dui-xiang-huo-qu"><span class="toc-text">sync.Pool对象获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-pool-dui-xiang-de-fan-hui"><span class="toc-text">sync.Pool对象的返回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shi-yong-sync-pool"><span class="toc-text">使用sync.Pool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-pool-dui-xiang-de-sheng-ming-zhou-qi"><span class="toc-text">sync.Pool对象的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-pool-zong-jie"><span class="toc-text">sync.Pool总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-zhong-de-mian-xiang-dui-xiang"><span class="toc-text">Go中的面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#feng-zhuang-shu-ju-he-xing-wei"><span class="toc-text">封装数据和行为</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jie-gou-ti-ding-yi"><span class="toc-text">结构体定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#duck-type-shi-jie-kou-shi-xian"><span class="toc-text">Duck Type式接口实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#go-jie-kou-yu-qi-ta-zhu-liu-bian-cheng-yu-yan-de-chai-yi"><span class="toc-text">Go接口与其他主流编程语言的差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#zi-ding-yi-lei-xing"><span class="toc-text">自定义类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kuo-zhan-yu-fu-yong"><span class="toc-text">扩展与复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#duo-tai"><span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kong-jie-kou-yu-duan-yan"><span class="toc-text">空接口与断言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ce-shi"><span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ce-shi-testing"><span class="toc-text">测试testing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dan-yuan-ce-shi"><span class="toc-text">单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#biao-ge-ce-shi-fa"><span class="toc-text">表格测试法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nei-zhi-dan-yuan-ce-shi-kuang-jia"><span class="toc-text">内置单元测试框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#benchmark"><span class="toc-text">BenchMark</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bdd"><span class="toc-text">BDD</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fan-she-bian-cheng"><span class="toc-text">反射编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reflect-typeof-vs-reflect-valueof"><span class="toc-text">reflect.TypeOf vs reflect.ValueOf</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pan-duan-lei-xing-kind"><span class="toc-text">判断类型-kind()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#li-yong-fan-she-bian-xie-ling-huo-de-dai-ma"><span class="toc-text">利用反射编写灵活的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-tag"><span class="toc-text">Struct Tag</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-tag-de-ke-xuan-zi-duan"><span class="toc-text">struct tag的可选字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fang-wen-struct-tag"><span class="toc-text">访问Struct Tag</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deepequal-bi-jiao-map-he-qie-pian"><span class="toc-text">DeepEqual 比较Map和切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wan-neng-cheng-xu"><span class="toc-text">万能程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fan-she-bi-yao-liao-jie"><span class="toc-text">反射必要了解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bu-an-quan-bian-cheng"><span class="toc-text">不安全编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bu-an-quan-xing-wei-de-wei-xian-xing"><span class="toc-text">不安全行为的危险性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bu-he-li-de-lei-xing-zhuan-huan-qiang-zhi-lei-xing-zhuan-huan"><span class="toc-text">不合理的类型转换（强制类型转换）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#he-li-de-lei-xing-zhuan-huan-bie-ming"><span class="toc-text">合理的类型转换（别名）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yuan-zi-lei-xing-de-cao-zuo"><span class="toc-text">原子类型的操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ruan-jian-jia-gou"><span class="toc-text">软件架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pipe-filter-jia-gou"><span class="toc-text">Pipe-Filter 架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shi-xian-micro-kernel-framework"><span class="toc-text">实现micro kernel framework</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chang-yong-ren-wu-x2f-gong-ju"><span class="toc-text">常用任务&#x2F;工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#json-jie-xi"><span class="toc-text">JSON解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#nei-zhi-json-jie-xi"><span class="toc-text">内置JSON解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#easyjson"><span class="toc-text">EasyJSON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-fu-wu"><span class="toc-text">HTTP服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lu-you-gui-ze"><span class="toc-text">路由规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gou-jian-restful-fu-wu"><span class="toc-text">构建RESTful服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#geng-hao-de-router"><span class="toc-text">更好的Router</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mian-xiang-zi-yuan-de-jia-gou-resource-oriented-architecture"><span class="toc-text">面向资源的架构（Resource Oriented Architecture）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xing-neng-fen-xi-yu-xing-neng-diao-you"><span class="toc-text">性能分析与性能调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pprof-zhi-nan"><span class="toc-text">pprof指南</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xing-neng-fen-xi-gong-ju"><span class="toc-text">性能分析工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tong-guo-wen-jian-fang-shi-shu-chu-profile"><span class="toc-text">通过文件方式输出Profile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#go-zhi-chi-de-duo-chong-profile"><span class="toc-text">Go支持的多种Profile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tong-guo-http-fang-shi-shu-chu-profile"><span class="toc-text">通过HTTP方式输出Profile</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xing-neng-diao-you"><span class="toc-text">性能调优</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#chang-jian-fen-xi-zhi-biao"><span class="toc-text">常见分析指标</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#example"><span class="toc-text">Example</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xing-neng-bu-neng-bei-suo-zhu"><span class="toc-text">性能不能被锁住</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#suo-dui-xing-neng-de-ying-xiang-bi-jiao-da"><span class="toc-text">锁对性能的影响比较大</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-map-yuan-map-bu-zhi-chi-xian-cheng-an-quan"><span class="toc-text">sync.Map,原Map不支持线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xing-neng-suo-xiao-jie"><span class="toc-text">性能锁小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#example"><span class="toc-text">Example</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gc-you-hao-dai-ma"><span class="toc-text">GC友好代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bi-mian-nei-cun-fen-pei-he-fu-zhi"><span class="toc-text">避免内存分配和复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#da-kai-gc-ri-zhi"><span class="toc-text">打开GC日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#go-tool-trace"><span class="toc-text">go tool trace</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pu-tong-cheng-xu-shu-chu"><span class="toc-text">普通程序输出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ce-shi-cheng-xu-shu-chu-trace-xin-xi"><span class="toc-text">测试程序输出trace信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ke-shi-hua-trace-xin-xi"><span class="toc-text">可视化trace信息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bi-mian-nei-cun-fen-pei-he-fu-zhi"><span class="toc-text">避免内存分配和复制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gao-xiao-zi-fu-chuan-lian-jie"><span class="toc-text">高效字符串连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fen-bu-shi-xi-tong-jia-gou-gao-ke-yong"><span class="toc-text">分布式系统架构（高可用）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mian-xiang-cuo-wu-she-ji"><span class="toc-text">面向错误设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ge-chi"><span class="toc-text">隔离</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#wei-nei-he"><span class="toc-text">微内核</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#wei-fu-wu"><span class="toc-text">微服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#chong-yong-vs-ge-chi"><span class="toc-text">重用 vs 隔离</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rong-yu"><span class="toc-text">冗余</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dan-dian-shi-xiao"><span class="toc-text">单点失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jie-jue-dan-dian-shi-xiao-xian-liu"><span class="toc-text">解决单点失效—— 限流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#man-xiang-ying"><span class="toc-text">慢响应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bu-yao-wu-xiu-zhi-de-deng-dai"><span class="toc-text">不要无休止的等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cuo-wu-chuan-di"><span class="toc-text">错误传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#duan-lu-qi"><span class="toc-text">断路器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mian-xiang-hui-fu-she-ji"><span class="toc-text">面向恢复设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jian-kang-jian-cha"><span class="toc-text">健康检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#let-it-crash"><span class="toc-text">Let it Crash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gou-jian-ke-hui-fu-de-xi-tong"><span class="toc-text">构建可恢复的系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yu-ke-hu-duan-xie-shang"><span class="toc-text">与客户端协商</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chaos-engineering"><span class="toc-text">chaos engineering</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cgaos-engineering-yuan-ze"><span class="toc-text">Cgaos Engineering原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xiang-guan-kai-yuan-xiang-mu"><span class="toc-text">相关开源项目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tu-shu-tui-jian"><span class="toc-text">图书推荐</span></a></li></ol></li></ol>
    </div>
</aside>-->
    <div id="toc">
        <strong class="sidebar-title">
            文章目录
        </strong>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#go-yu-yan-cong-ru-men-dao-shi-zhan-bi-ji"><span class="toc-text">Go 语言从入门到实战 笔记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ji-chu-bu-fen"><span class="toc-text">基础部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#chai-yi-yu-ji-chu"><span class="toc-text">差异与基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tui-chu-fan-hui-zhi"><span class="toc-text">退出返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#huo-qu-ming-ling-xing-can-shu"><span class="toc-text">获取命令行参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bian-liang-fu-zhi"><span class="toc-text">变量赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kuai-su-she-zhi-lian-xu-zhi"><span class="toc-text">快速设置连续值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lei-xing-zhuan-hua"><span class="toc-text">类型转化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zhi-zhen-lei-xing"><span class="toc-text">指针类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#suan-zhu-yun-suan-fu"><span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yong-bi-jiao-shu-zu"><span class="toc-text">用&#x3D;&#x3D;比较数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wei-yun-suan-fu-amp-an-wei-zhi-ling"><span class="toc-text">位运算符，&amp;^按位置零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xun-huan"><span class="toc-text">循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-tiao-jian"><span class="toc-text">if条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch-tiao-jian"><span class="toc-text">switch条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#qie-pian"><span class="toc-text">切片</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#qie-pian-sheng-ming"><span class="toc-text">切片声明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#qie-pian-ru-he-shi-xian-ke-bian-chang"><span class="toc-text">切片如何实现可变长</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-sheng-ming"><span class="toc-text">Map声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#map-yuan-su-de-fang-wen"><span class="toc-text">Map元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-bian-li"><span class="toc-text">Map遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-yu-gong-han-mo-shi"><span class="toc-text">Map与工厂模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shi-xian-set"><span class="toc-text">实现Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zi-fu-chuan"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#unicode-utf8"><span class="toc-text">Unicode UTF8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string-zhuan-rune"><span class="toc-text">String转rune</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chang-yong-de-zi-fu-chuan-han-shu"><span class="toc-text">常用的字符串函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#han-shu-shi-yi-deng-gong-min"><span class="toc-text">函数是一等公民</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ke-bian-can-shu"><span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#defer-han-shu"><span class="toc-text">defer函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-de-cuo-wu-ji-zhi"><span class="toc-text">Go的错误机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#panic"><span class="toc-text">panic</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#panic-vs-os-exit"><span class="toc-text">panic VS os.Exit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bu-huo-suo-you-cuo-wu-recover"><span class="toc-text">捕获所有错误 recover</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3d-x3d-shi-yong-recover-xu-jin-shen-x3d-x3d"><span class="toc-text">&#x3D;&#x3D;使用recover需谨慎&#x3D;&#x3D;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-de-yi-lai-guan-li"><span class="toc-text">GO的依赖管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#package"><span class="toc-text">package</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#remote-package"><span class="toc-text">remote package</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#init-fang-fa"><span class="toc-text">init方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#init-han-shu-de-zhu-yao-zuo-yong"><span class="toc-text">init函数的主要作用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init-han-shu-de-zhu-yao-te-dian"><span class="toc-text">init函数的主要特点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-wei-jie-jue-de-yi-lai-wen-ti"><span class="toc-text">Go未解决的依赖问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vendor-lu-jing"><span class="toc-text">vendor路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chang-yong-de-yi-lai-guan-li-gong-ju"><span class="toc-text">常用的依赖管理工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-de-jiao-cha-bian-yi"><span class="toc-text">Go的交叉编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bing-fa-bian-cheng"><span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-vs-groutine"><span class="toc-text">Thread VS Groutine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gong-xiang-nei-cun-bing-fa-ji-zhi"><span class="toc-text">共享内存并发机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-mutex-hu-chi-suo"><span class="toc-text">sync.Mutex 互斥锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-waitgroup-tong-bu-xian-cheng-lei-si-java-zhong-de-join"><span class="toc-text">sync.WaitGroup同步线程 类似java中的join</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#csp-bing-fa-ji-zhi-go-yu-yan-te-you-de"><span class="toc-text">CSP并发机制（Go语言特有的）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#csp-vs-actor"><span class="toc-text">CSP vs Actor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#channel"><span class="toc-text">Channel</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#duo-lu-xuan-ze-he-chao-shi"><span class="toc-text">多路选择和超时</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#duo-lu-xuan-ze"><span class="toc-text">多路选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chao-shi-kong-zhi"><span class="toc-text">超时控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#channel-de-guan-bi"><span class="toc-text">channel的关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ren-wu-qu-xiao"><span class="toc-text">任务取消</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#context-yu-ren-wu-qu-xiao"><span class="toc-text">Context 与 任务取消</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#context"><span class="toc-text">Context</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zhi-yun-xing-yi-ci"><span class="toc-text">只运行一次</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dan-li-mo-shi-lan-han-shi-xian-cheng-an-quan"><span class="toc-text">单例模式 （懒汉式，线程安全）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jin-xu-ren-yi-ren-wu-wan-cheng"><span class="toc-text">仅需任意任务完成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#suo-you-ren-wu-wan-cheng"><span class="toc-text">所有任务完成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dui-xiang-chi"><span class="toc-text">对象池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sync-pool-dui-xiang-huan-cun"><span class="toc-text">sync.Pool对象缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-pool-dui-xiang-huo-qu"><span class="toc-text">sync.Pool对象获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-pool-dui-xiang-de-fan-hui"><span class="toc-text">sync.Pool对象的返回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shi-yong-sync-pool"><span class="toc-text">使用sync.Pool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-pool-dui-xiang-de-sheng-ming-zhou-qi"><span class="toc-text">sync.Pool对象的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-pool-zong-jie"><span class="toc-text">sync.Pool总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-zhong-de-mian-xiang-dui-xiang"><span class="toc-text">Go中的面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#feng-zhuang-shu-ju-he-xing-wei"><span class="toc-text">封装数据和行为</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jie-gou-ti-ding-yi"><span class="toc-text">结构体定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#duck-type-shi-jie-kou-shi-xian"><span class="toc-text">Duck Type式接口实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#go-jie-kou-yu-qi-ta-zhu-liu-bian-cheng-yu-yan-de-chai-yi"><span class="toc-text">Go接口与其他主流编程语言的差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#zi-ding-yi-lei-xing"><span class="toc-text">自定义类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kuo-zhan-yu-fu-yong"><span class="toc-text">扩展与复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#duo-tai"><span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kong-jie-kou-yu-duan-yan"><span class="toc-text">空接口与断言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ce-shi"><span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ce-shi-testing"><span class="toc-text">测试testing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dan-yuan-ce-shi"><span class="toc-text">单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#biao-ge-ce-shi-fa"><span class="toc-text">表格测试法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nei-zhi-dan-yuan-ce-shi-kuang-jia"><span class="toc-text">内置单元测试框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#benchmark"><span class="toc-text">BenchMark</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bdd"><span class="toc-text">BDD</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fan-she-bian-cheng"><span class="toc-text">反射编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reflect-typeof-vs-reflect-valueof"><span class="toc-text">reflect.TypeOf vs reflect.ValueOf</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pan-duan-lei-xing-kind"><span class="toc-text">判断类型-kind()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#li-yong-fan-she-bian-xie-ling-huo-de-dai-ma"><span class="toc-text">利用反射编写灵活的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-tag"><span class="toc-text">Struct Tag</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-tag-de-ke-xuan-zi-duan"><span class="toc-text">struct tag的可选字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fang-wen-struct-tag"><span class="toc-text">访问Struct Tag</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deepequal-bi-jiao-map-he-qie-pian"><span class="toc-text">DeepEqual 比较Map和切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wan-neng-cheng-xu"><span class="toc-text">万能程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fan-she-bi-yao-liao-jie"><span class="toc-text">反射必要了解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bu-an-quan-bian-cheng"><span class="toc-text">不安全编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bu-an-quan-xing-wei-de-wei-xian-xing"><span class="toc-text">不安全行为的危险性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bu-he-li-de-lei-xing-zhuan-huan-qiang-zhi-lei-xing-zhuan-huan"><span class="toc-text">不合理的类型转换（强制类型转换）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#he-li-de-lei-xing-zhuan-huan-bie-ming"><span class="toc-text">合理的类型转换（别名）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yuan-zi-lei-xing-de-cao-zuo"><span class="toc-text">原子类型的操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ruan-jian-jia-gou"><span class="toc-text">软件架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pipe-filter-jia-gou"><span class="toc-text">Pipe-Filter 架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shi-xian-micro-kernel-framework"><span class="toc-text">实现micro kernel framework</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chang-yong-ren-wu-x2f-gong-ju"><span class="toc-text">常用任务&#x2F;工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#json-jie-xi"><span class="toc-text">JSON解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#nei-zhi-json-jie-xi"><span class="toc-text">内置JSON解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#easyjson"><span class="toc-text">EasyJSON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-fu-wu"><span class="toc-text">HTTP服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lu-you-gui-ze"><span class="toc-text">路由规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gou-jian-restful-fu-wu"><span class="toc-text">构建RESTful服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#geng-hao-de-router"><span class="toc-text">更好的Router</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mian-xiang-zi-yuan-de-jia-gou-resource-oriented-architecture"><span class="toc-text">面向资源的架构（Resource Oriented Architecture）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xing-neng-fen-xi-yu-xing-neng-diao-you"><span class="toc-text">性能分析与性能调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pprof-zhi-nan"><span class="toc-text">pprof指南</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xing-neng-fen-xi-gong-ju"><span class="toc-text">性能分析工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tong-guo-wen-jian-fang-shi-shu-chu-profile"><span class="toc-text">通过文件方式输出Profile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#go-zhi-chi-de-duo-chong-profile"><span class="toc-text">Go支持的多种Profile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tong-guo-http-fang-shi-shu-chu-profile"><span class="toc-text">通过HTTP方式输出Profile</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xing-neng-diao-you"><span class="toc-text">性能调优</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#chang-jian-fen-xi-zhi-biao"><span class="toc-text">常见分析指标</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#example"><span class="toc-text">Example</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xing-neng-bu-neng-bei-suo-zhu"><span class="toc-text">性能不能被锁住</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#suo-dui-xing-neng-de-ying-xiang-bi-jiao-da"><span class="toc-text">锁对性能的影响比较大</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-map-yuan-map-bu-zhi-chi-xian-cheng-an-quan"><span class="toc-text">sync.Map,原Map不支持线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xing-neng-suo-xiao-jie"><span class="toc-text">性能锁小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#example"><span class="toc-text">Example</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gc-you-hao-dai-ma"><span class="toc-text">GC友好代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bi-mian-nei-cun-fen-pei-he-fu-zhi"><span class="toc-text">避免内存分配和复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#da-kai-gc-ri-zhi"><span class="toc-text">打开GC日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#go-tool-trace"><span class="toc-text">go tool trace</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pu-tong-cheng-xu-shu-chu"><span class="toc-text">普通程序输出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ce-shi-cheng-xu-shu-chu-trace-xin-xi"><span class="toc-text">测试程序输出trace信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ke-shi-hua-trace-xin-xi"><span class="toc-text">可视化trace信息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bi-mian-nei-cun-fen-pei-he-fu-zhi"><span class="toc-text">避免内存分配和复制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gao-xiao-zi-fu-chuan-lian-jie"><span class="toc-text">高效字符串连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fen-bu-shi-xi-tong-jia-gou-gao-ke-yong"><span class="toc-text">分布式系统架构（高可用）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mian-xiang-cuo-wu-she-ji"><span class="toc-text">面向错误设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ge-chi"><span class="toc-text">隔离</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#wei-nei-he"><span class="toc-text">微内核</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#wei-fu-wu"><span class="toc-text">微服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#chong-yong-vs-ge-chi"><span class="toc-text">重用 vs 隔离</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rong-yu"><span class="toc-text">冗余</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dan-dian-shi-xiao"><span class="toc-text">单点失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jie-jue-dan-dian-shi-xiao-xian-liu"><span class="toc-text">解决单点失效—— 限流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#man-xiang-ying"><span class="toc-text">慢响应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bu-yao-wu-xiu-zhi-de-deng-dai"><span class="toc-text">不要无休止的等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cuo-wu-chuan-di"><span class="toc-text">错误传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#duan-lu-qi"><span class="toc-text">断路器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mian-xiang-hui-fu-she-ji"><span class="toc-text">面向恢复设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jian-kang-jian-cha"><span class="toc-text">健康检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#let-it-crash"><span class="toc-text">Let it Crash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gou-jian-ke-hui-fu-de-xi-tong"><span class="toc-text">构建可恢复的系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yu-ke-hu-duan-xie-shang"><span class="toc-text">与客户端协商</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chaos-engineering"><span class="toc-text">chaos engineering</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cgaos-engineering-yuan-ze"><span class="toc-text">Cgaos Engineering原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xiang-guan-kai-yuan-xiang-mu"><span class="toc-text">相关开源项目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tu-shu-tui-jian"><span class="toc-text">图书推荐</span></a></li></ol></li></ol>
    </div>
    


        <!--                data-theme="white_high_contrast"-->
        <hr class="fhr">
        <!--        <div id="vcomments"></div>-->
        <div class="giscus" >
            <script src="https://giscus.app/client.js"
                    data-repo="NetLops/netlops.github.io"
                    data-repo-id="MDEwOlJlcG9zaXRvcnk0MDE5MzQxNjM="
                    data-category="Announcements"
                    data-category-id="DIC_kwDOF_UHU84CRDpg"
                    data-mapping="pathname"
                    data-strict="0"
                    data-reactions-enabled="1"
                    data-emit-metadata="0"
                    data-input-position="top"
                    data-theme="transparent_dark"
                    data-loading="lazy"
                    data-lang="zh-CN"
                    crossorigin="anonymous"
                    async>
            </script>
        </div>
    
</div>

    <div class="footer" id="footer">
    <p>Copyright © 2020 - 2022 <a class="flink" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>-<a class="flink" target="_blank" rel="noopener" href="https://github.com/sanjinhub/hexo-theme-geek">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="white">
<input type="hidden" id="valine_appid" value="CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="FqiyUqbg7McKN2eG0MCewupf">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>




<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>

</body>

</html>